{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Index"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"About Us We are third-year students at EPITECH Cotonou. We are programmers and developers. It's our passion and devotion that motivates us to give our best. Contributeurs Leobasthene LIMA : ( GitHub | LinkedIn ) Deo-gratias PATINVOH : ( GitHub | LinkedIn ) Ishola AREMOU : ( GitHub ) Jaurio DANSOU : ( GitHub ) Mohamed ONIFADE : ( GitHub | LinkedIn ) Zaidane KODJOGBE : ( GitHub | LinkedIn )","title":"About"},{"location":"about/#about-us","text":"We are third-year students at EPITECH Cotonou. We are programmers and developers. It's our passion and devotion that motivates us to give our best.","title":"About Us"},{"location":"about/#contributeurs","text":"Leobasthene LIMA : ( GitHub | LinkedIn ) Deo-gratias PATINVOH : ( GitHub | LinkedIn ) Ishola AREMOU : ( GitHub ) Jaurio DANSOU : ( GitHub ) Mohamed ONIFADE : ( GitHub | LinkedIn ) Zaidane KODJOGBE : ( GitHub | LinkedIn )","title":"Contributeurs"},{"location":"client/","text":"Class ClientENet The ClientENet class is responsible for creating and managing an ENet client using the ENet library for network communication. Methods ClientENet() The constructor of the ClientENet class initializes the ENet library by calling the enet_initialize() function. If initialization fails, an error message is printed. ~ClientENet() The destructor of the ClientENet class disconnects from the server by calling the Disconnect() method and releases the resources used by the ENet library by calling the enet_deinitialize() function. Connect(const char* serverAddress, int port) The Connect method connects the client to the server. It takes a serverAddress parameter as a string representing the server's IP address and a port parameter as an integer representing the server's port number. The method performs the following operations: If the client is already connected, it disconnects first by calling the Disconnect() method. Sets the server's address using the enet_address_set_host() function. Creates an ENet host using the enet_host_create() function with parameters (null for the address, 1 channel for outgoing traffic, 2 channels for incoming traffic, no outgoing bandwidth limit, no incoming bandwidth limit). If the host creation fails, an error message is printed, and the method returns false. Connects to the server using the enet_host_connect() function. If the connection to the server is successful, the method waits for an event using the enet_host_service() function. If a connection event is received within 5 seconds, a success message is printed, and the method returns true. Otherwise, a failure message is printed, and the method returns false. Disconnect() The Disconnect method disconnects the client from the server. It resets the peer using the enet_peer_reset() function, flushes the host using the enet_host_flush() function, destroys the host using the enet_host_destroy() function, and sets the client and peer pointers to null. A disconnection message is printed. IsConnected() The IsConnected method checks if the client is connected to the server. It returns true if both the client and peer pointers are not null; otherwise, it returns false. SendData(const void* data, size_t dataSize) The SendData method sends data to the server. It takes a data parameter as a pointer to the data to be sent and a dataSize parameter as the size of the data. The method performs the following operations: Checks if the client is connected. Creates an ENet packet using the enet_packet_create() function with the data, data size, and reliable flag. Sends the packet to the peer using the enet_peer_send() function. Flushes the host using the enet_host_flush() function. Update() The Update method updates the client by handling incoming network events. It checks if the client is connected and then enters a while loop to process events using the enet_host_service() function. The method performs the following operations: Checks if the client is connected. Waits for an event using the enet_host_service() function. Processes the event based on its type: ENET_EVENT_TYPE_RECEIVE: Handles received data by destroying the packet. ENET_EVENT_TYPE_DISCONNECT: Handles disconnection by calling the Disconnect() method. main() function The main function is the entry point of the program. It creates an instance of the ClientENet class and a Window object. It retrieves the server address and port from the command-line arguments. If the client successfully connects to the server, it sends data to the server, runs the window, and enters a loop to update the client while it is connected. If the connection fails, the client is disconnected. Please note that to use this code, you need to include the \"Client.hpp\" header file and the ENet library using #include . Also, make sure you have the ENet library installed and properly configured.","title":"ENet Client"},{"location":"client/#class-clientenet","text":"The ClientENet class is responsible for creating and managing an ENet client using the ENet library for network communication.","title":"Class ClientENet"},{"location":"client/#methods","text":"","title":"Methods"},{"location":"client/#clientenet","text":"The constructor of the ClientENet class initializes the ENet library by calling the enet_initialize() function. If initialization fails, an error message is printed.","title":"ClientENet()"},{"location":"client/#clientenet_1","text":"The destructor of the ClientENet class disconnects from the server by calling the Disconnect() method and releases the resources used by the ENet library by calling the enet_deinitialize() function.","title":"~ClientENet()"},{"location":"client/#connectconst-char-serveraddress-int-port","text":"The Connect method connects the client to the server. It takes a serverAddress parameter as a string representing the server's IP address and a port parameter as an integer representing the server's port number. The method performs the following operations: If the client is already connected, it disconnects first by calling the Disconnect() method. Sets the server's address using the enet_address_set_host() function. Creates an ENet host using the enet_host_create() function with parameters (null for the address, 1 channel for outgoing traffic, 2 channels for incoming traffic, no outgoing bandwidth limit, no incoming bandwidth limit). If the host creation fails, an error message is printed, and the method returns false. Connects to the server using the enet_host_connect() function. If the connection to the server is successful, the method waits for an event using the enet_host_service() function. If a connection event is received within 5 seconds, a success message is printed, and the method returns true. Otherwise, a failure message is printed, and the method returns false.","title":"Connect(const char* serverAddress, int port)"},{"location":"client/#disconnect","text":"The Disconnect method disconnects the client from the server. It resets the peer using the enet_peer_reset() function, flushes the host using the enet_host_flush() function, destroys the host using the enet_host_destroy() function, and sets the client and peer pointers to null. A disconnection message is printed.","title":"Disconnect()"},{"location":"client/#isconnected","text":"The IsConnected method checks if the client is connected to the server. It returns true if both the client and peer pointers are not null; otherwise, it returns false.","title":"IsConnected()"},{"location":"client/#senddataconst-void-data-size_t-datasize","text":"The SendData method sends data to the server. It takes a data parameter as a pointer to the data to be sent and a dataSize parameter as the size of the data. The method performs the following operations: Checks if the client is connected. Creates an ENet packet using the enet_packet_create() function with the data, data size, and reliable flag. Sends the packet to the peer using the enet_peer_send() function. Flushes the host using the enet_host_flush() function.","title":"SendData(const void* data, size_t dataSize)"},{"location":"client/#update","text":"The Update method updates the client by handling incoming network events. It checks if the client is connected and then enters a while loop to process events using the enet_host_service() function. The method performs the following operations: Checks if the client is connected. Waits for an event using the enet_host_service() function. Processes the event based on its type: ENET_EVENT_TYPE_RECEIVE: Handles received data by destroying the packet. ENET_EVENT_TYPE_DISCONNECT: Handles disconnection by calling the Disconnect() method.","title":"Update()"},{"location":"client/#main-function","text":"The main function is the entry point of the program. It creates an instance of the ClientENet class and a Window object. It retrieves the server address and port from the command-line arguments. If the client successfully connects to the server, it sends data to the server, runs the window, and enters a loop to update the client while it is connected. If the connection fails, the client is disconnected. Please note that to use this code, you need to include the \"Client.hpp\" header file and the ENet library using #include . Also, make sure you have the ENet library installed and properly configured.","title":"main() function"},{"location":"client_game/","text":"Here is the documentation generated from the provided code: Game Class The Game class represents the game itself and manages the main logic of the game. Methods Constructor Game::Game(std::queue<GamePacket>& packets, std::mutex& mutex) This constructor initializes the Game class with a queue of received packets and a mutex to protect the queue. packets : The queue of received packets. mutex : The mutex used to protect the queue. run Method void Game::run() noexcept This method runs the game. It clears the window, deserializes the received packets, and draws the entities. getLib Method Lib& Game::getLib() noexcept This method returns a reference to the Lib object stored in the Game object. updateOrCreateEntity Method void Game::updateOrCreateEntity(GamePacket packet) noexcept This method deserializes a packet and creates an entity if it does not exist or updates it if it already exists. packet : The packet received from the server. createSound Method int Game::createSound(const std::string_view& path) noexcept This method creates a new entity, adds a sound component to it, and returns the entity's identifier. path : The path to the sound file. getManager Method EntityManager& Game::getManager() noexcept This method returns a reference to our entity manager. Attributes The following attributes are declared in the Game class: dataReceived_ : The queue of received packets. mutexForPacket_ : The mutex used to protect the queue. drawableSystem_ : The system responsible for rendering entities. destroyableSystem_ : The system responsible for entity destruction management. soundSystem_ : The system responsible for sound management. musicSystem_ : The system responsible for music management. lib_ : The Lib object used by the game. soundManager_ : The sound manager. soundPaths_ : The paths of sound files. manager_ : The entity manager. GamePacket Class The GamePacket class represents a game packet received from the server. Attributes The following attributes are declared in the GamePacket class: id : The packet identifier. x : The X position of the entity associated with the packet. y : The Y position of the entity associated with the packet. offsetX : The X offset of the entity associated with the packet. offsetY : The Y offset of the entity associated with the packet. width : The width of the entity associated with the packet. height : The height of the entity associated with the packet. idSprite : The texture identifier of the entity associated with the packet. scaleX : The horizontal scale of the entity associated with the packet. scaleY : The vertical scale of the entity associated with the packet. destroyed : An indicator indicating whether the entity associated with the packet is destroyed. id_is_player : An indicator indicating whether the entity associated with the packet is a player. life : The number of lives of the player associated with the packet. score : The score of the player associated with the packet. Lib Class The Lib class represents a library used by the game. Methods getWindow Method Window& Lib::getWindow() noexcept This method returns a reference to the library's window. EntityManager Class The EntityManager class represents an entity manager. Methods getEntity Method Entity* EntityManager::getEntity(size_t id) const This method returns a pointer to the entity corresponding to the given identifier. id : The identifier of the entity to retrieve. newEntity Method Entity* EntityManager::newEntity(size_t id = 0) This method creates a new entity with the given identifier and returns a pointer to that entity. id : The identifier of the new entity (default: 0). getId Method size_t Entity::getId() const This method returns the identifier of the entity. Entity Class The Entity class represents an entity in the game. Methods addComponent Method template <typename T> void Entity::addComponent(T component) This method adds a component to the entity. component : The component to add. getComponent Method template <typename T> T Entity::getComponent() const This method returns a pointer to the component of type T of the entity, or nullptr if the component does not exist. -Voici la documentation g\u00e9n\u00e9r\u00e9e \u00e0 partir du code fourni : Classe Game La classe \"Game\" repr\u00e9sente le jeu lui-m\u00eame et g\u00e8re la logique principale du jeu. M\u00e9thodes Constructeur Game::Game(std::queue<GamePacket>& packets, std::mutex& mutex) Ce constructeur initialise la classe \"Game\" avec une file de paquets re\u00e7us et un mutex pour prot\u00e9ger la file. packets : La file de paquets re\u00e7us. mutex : Le mutex utilis\u00e9 pour prot\u00e9ger la file. M\u00e9thode run void Game::run() noexcept Cette m\u00e9thode ex\u00e9cute le jeu. Elle efface la fen\u00eatre, d\u00e9s\u00e9rialise les paquets re\u00e7us et dessine les entit\u00e9s. M\u00e9thode getLib Lib& Game::getLib() noexcept Cette m\u00e9thode renvoie une r\u00e9f\u00e9rence \u00e0 l'objet \"Lib\" stock\u00e9 dans l'objet \"Game\". M\u00e9thode updateOrCreateEntity void Game::updateOrCreateEntity(GamePacket packet) noexcept Cette m\u00e9thode d\u00e9s\u00e9rialise un paquet et cr\u00e9e une entit\u00e9 si elle n'existe pas d\u00e9j\u00e0, ou la met \u00e0 jour si elle existe d\u00e9j\u00e0. packet : Le paquet re\u00e7u du serveur. M\u00e9thode createSound int Game::createSound(const std::string_view& path) noexcept Cette m\u00e9thode cr\u00e9e une nouvelle entit\u00e9, ajoute un composant sonore et renvoie l'identifiant de l'entit\u00e9. path : Le chemin du fichier sonore. M\u00e9thode getManager EntityManager& Game::getManager() noexcept Cette m\u00e9thode renvoie une r\u00e9f\u00e9rence \u00e0 notre gestionnaire d'entit\u00e9s. Attributs Les attributs suivants sont d\u00e9clar\u00e9s dans la classe \"Game\": dataReceived_ : La file de paquets re\u00e7us. mutexForPacket_ : Le mutex utilis\u00e9 pour prot\u00e9ger la file. drawableSystem_ : Le syst\u00e8me responsable du rendu des entit\u00e9s. destroyableSystem_ : Le syst\u00e8me responsable de la gestion de destruction des entit\u00e9s. soundSystem_ : Le syst\u00e8me responsable de la gestion du son. musicSystem_ : Le syst\u00e8me responsable de la gestion de la musique. lib_ : L'objet \"Lib\" utilis\u00e9 par le jeu. soundManager_ : Le gestionnaire de son. soundPaths_ : Les chemins des fichiers sonores. manager_ : Le gestionnaire d'entit\u00e9s. Classe GamePacket La classe \"GamePacket\" repr\u00e9sente un paquet de jeu re\u00e7u du serveur. Attributs Les attributs suivants sont d\u00e9clar\u00e9s dans la classe \"GamePacket\": id : L'identifiant du paquet. x : La position X de l'entit\u00e9 associ\u00e9e au paquet. y : La position Y de l'entit\u00e9 associ\u00e9e au paquet. offsetX : Le d\u00e9calage X de l'entit\u00e9 associ\u00e9e au paquet. offsetY : Le d\u00e9calage Y de l'entit\u00e9 associ\u00e9e au paquet. width : La largeur de l'entit\u00e9 associ\u00e9e au paquet. height : La hauteur de l'entit\u00e9 associ\u00e9e au paquet. idSprite : L'identifiant de texture de l'entit\u00e9 associ\u00e9e au paquet. scaleX : L'\u00e9chelle horizontale de l'entit\u00e9 associ\u00e9e au paquet. scaleY : L'\u00e9chelle verticale de l'entit\u00e9 associ\u00e9e au paquet. destroyed : Un indicateur indiquant si l'entit\u00e9 associ\u00e9e au paquet est d\u00e9truite. id_is_player : Un indicateur indiquant si l'entit\u00e9 associ\u00e9e au paquet est un joueur. life : Le nombre de vies du joueur associ\u00e9 au paquet. score : Le score du joueur associ\u00e9 au paquet. Classe Lib La classe \"Lib\" repr\u00e9sente une biblioth\u00e8que utilis\u00e9e par le jeu. M\u00e9thodes M\u00e9thode getWindow Window& Lib::getWindow() noexcept Cette m\u00e9thode renvoie une r\u00e9f\u00e9rence \u00e0 la fen\u00eatre de la biblioth\u00e8que. Classe EntityManager La classe \"EntityManager\" repr\u00e9sente un gestionnaire d'entit\u00e9s. M\u00e9thodes M\u00e9thode getEntity Entity* EntityManager::getEntity(size_t id) const Cette m\u00e9thode renvoie un pointeur vers l'entit\u00e9 correspondant \u00e0 l'ident","title":"Game Client"},{"location":"client_game/#game-class","text":"The Game class represents the game itself and manages the main logic of the game. Methods Constructor Game::Game(std::queue<GamePacket>& packets, std::mutex& mutex) This constructor initializes the Game class with a queue of received packets and a mutex to protect the queue. packets : The queue of received packets. mutex : The mutex used to protect the queue. run Method void Game::run() noexcept This method runs the game. It clears the window, deserializes the received packets, and draws the entities. getLib Method Lib& Game::getLib() noexcept This method returns a reference to the Lib object stored in the Game object. updateOrCreateEntity Method void Game::updateOrCreateEntity(GamePacket packet) noexcept This method deserializes a packet and creates an entity if it does not exist or updates it if it already exists. packet : The packet received from the server. createSound Method int Game::createSound(const std::string_view& path) noexcept This method creates a new entity, adds a sound component to it, and returns the entity's identifier. path : The path to the sound file. getManager Method EntityManager& Game::getManager() noexcept This method returns a reference to our entity manager. Attributes The following attributes are declared in the Game class: dataReceived_ : The queue of received packets. mutexForPacket_ : The mutex used to protect the queue. drawableSystem_ : The system responsible for rendering entities. destroyableSystem_ : The system responsible for entity destruction management. soundSystem_ : The system responsible for sound management. musicSystem_ : The system responsible for music management. lib_ : The Lib object used by the game. soundManager_ : The sound manager. soundPaths_ : The paths of sound files. manager_ : The entity manager.","title":"Game Class"},{"location":"client_game/#gamepacket-class","text":"The GamePacket class represents a game packet received from the server. Attributes The following attributes are declared in the GamePacket class: id : The packet identifier. x : The X position of the entity associated with the packet. y : The Y position of the entity associated with the packet. offsetX : The X offset of the entity associated with the packet. offsetY : The Y offset of the entity associated with the packet. width : The width of the entity associated with the packet. height : The height of the entity associated with the packet. idSprite : The texture identifier of the entity associated with the packet. scaleX : The horizontal scale of the entity associated with the packet. scaleY : The vertical scale of the entity associated with the packet. destroyed : An indicator indicating whether the entity associated with the packet is destroyed. id_is_player : An indicator indicating whether the entity associated with the packet is a player. life : The number of lives of the player associated with the packet. score : The score of the player associated with the packet.","title":"GamePacket Class"},{"location":"client_game/#lib-class","text":"The Lib class represents a library used by the game. Methods getWindow Method Window& Lib::getWindow() noexcept This method returns a reference to the library's window.","title":"Lib Class"},{"location":"client_game/#entitymanager-class","text":"The EntityManager class represents an entity manager. Methods getEntity Method Entity* EntityManager::getEntity(size_t id) const This method returns a pointer to the entity corresponding to the given identifier. id : The identifier of the entity to retrieve. newEntity Method Entity* EntityManager::newEntity(size_t id = 0) This method creates a new entity with the given identifier and returns a pointer to that entity. id : The identifier of the new entity (default: 0). getId Method size_t Entity::getId() const This method returns the identifier of the entity.","title":"EntityManager Class"},{"location":"client_game/#entity-class","text":"The Entity class represents an entity in the game. Methods addComponent Method template <typename T> void Entity::addComponent(T component) This method adds a component to the entity. component : The component to add. getComponent Method template <typename T> T Entity::getComponent() const This method returns a pointer to the component of type T of the entity, or nullptr if the component does not exist. -Voici la documentation g\u00e9n\u00e9r\u00e9e \u00e0 partir du code fourni :","title":"Entity Class"},{"location":"client_game/#classe-game","text":"La classe \"Game\" repr\u00e9sente le jeu lui-m\u00eame et g\u00e8re la logique principale du jeu. M\u00e9thodes Constructeur Game::Game(std::queue<GamePacket>& packets, std::mutex& mutex) Ce constructeur initialise la classe \"Game\" avec une file de paquets re\u00e7us et un mutex pour prot\u00e9ger la file. packets : La file de paquets re\u00e7us. mutex : Le mutex utilis\u00e9 pour prot\u00e9ger la file. M\u00e9thode run void Game::run() noexcept Cette m\u00e9thode ex\u00e9cute le jeu. Elle efface la fen\u00eatre, d\u00e9s\u00e9rialise les paquets re\u00e7us et dessine les entit\u00e9s. M\u00e9thode getLib Lib& Game::getLib() noexcept Cette m\u00e9thode renvoie une r\u00e9f\u00e9rence \u00e0 l'objet \"Lib\" stock\u00e9 dans l'objet \"Game\". M\u00e9thode updateOrCreateEntity void Game::updateOrCreateEntity(GamePacket packet) noexcept Cette m\u00e9thode d\u00e9s\u00e9rialise un paquet et cr\u00e9e une entit\u00e9 si elle n'existe pas d\u00e9j\u00e0, ou la met \u00e0 jour si elle existe d\u00e9j\u00e0. packet : Le paquet re\u00e7u du serveur. M\u00e9thode createSound int Game::createSound(const std::string_view& path) noexcept Cette m\u00e9thode cr\u00e9e une nouvelle entit\u00e9, ajoute un composant sonore et renvoie l'identifiant de l'entit\u00e9. path : Le chemin du fichier sonore. M\u00e9thode getManager EntityManager& Game::getManager() noexcept Cette m\u00e9thode renvoie une r\u00e9f\u00e9rence \u00e0 notre gestionnaire d'entit\u00e9s. Attributs Les attributs suivants sont d\u00e9clar\u00e9s dans la classe \"Game\": dataReceived_ : La file de paquets re\u00e7us. mutexForPacket_ : Le mutex utilis\u00e9 pour prot\u00e9ger la file. drawableSystem_ : Le syst\u00e8me responsable du rendu des entit\u00e9s. destroyableSystem_ : Le syst\u00e8me responsable de la gestion de destruction des entit\u00e9s. soundSystem_ : Le syst\u00e8me responsable de la gestion du son. musicSystem_ : Le syst\u00e8me responsable de la gestion de la musique. lib_ : L'objet \"Lib\" utilis\u00e9 par le jeu. soundManager_ : Le gestionnaire de son. soundPaths_ : Les chemins des fichiers sonores. manager_ : Le gestionnaire d'entit\u00e9s.","title":"Classe Game"},{"location":"client_game/#classe-gamepacket","text":"La classe \"GamePacket\" repr\u00e9sente un paquet de jeu re\u00e7u du serveur. Attributs Les attributs suivants sont d\u00e9clar\u00e9s dans la classe \"GamePacket\": id : L'identifiant du paquet. x : La position X de l'entit\u00e9 associ\u00e9e au paquet. y : La position Y de l'entit\u00e9 associ\u00e9e au paquet. offsetX : Le d\u00e9calage X de l'entit\u00e9 associ\u00e9e au paquet. offsetY : Le d\u00e9calage Y de l'entit\u00e9 associ\u00e9e au paquet. width : La largeur de l'entit\u00e9 associ\u00e9e au paquet. height : La hauteur de l'entit\u00e9 associ\u00e9e au paquet. idSprite : L'identifiant de texture de l'entit\u00e9 associ\u00e9e au paquet. scaleX : L'\u00e9chelle horizontale de l'entit\u00e9 associ\u00e9e au paquet. scaleY : L'\u00e9chelle verticale de l'entit\u00e9 associ\u00e9e au paquet. destroyed : Un indicateur indiquant si l'entit\u00e9 associ\u00e9e au paquet est d\u00e9truite. id_is_player : Un indicateur indiquant si l'entit\u00e9 associ\u00e9e au paquet est un joueur. life : Le nombre de vies du joueur associ\u00e9 au paquet. score : Le score du joueur associ\u00e9 au paquet.","title":"Classe GamePacket"},{"location":"client_game/#classe-lib","text":"La classe \"Lib\" repr\u00e9sente une biblioth\u00e8que utilis\u00e9e par le jeu. M\u00e9thodes M\u00e9thode getWindow Window& Lib::getWindow() noexcept Cette m\u00e9thode renvoie une r\u00e9f\u00e9rence \u00e0 la fen\u00eatre de la biblioth\u00e8que.","title":"Classe Lib"},{"location":"client_game/#classe-entitymanager","text":"La classe \"EntityManager\" repr\u00e9sente un gestionnaire d'entit\u00e9s. M\u00e9thodes M\u00e9thode getEntity Entity* EntityManager::getEntity(size_t id) const Cette m\u00e9thode renvoie un pointeur vers l'entit\u00e9 correspondant \u00e0 l'ident","title":"Classe EntityManager"},{"location":"ecs_component/","text":"ComponentBehavior Description The ComponentBehavior class is a derived class of IComponent and represents the behavior component of an entity. It provides functionality for updating the entity's behavior. Public Members ComponentBehavior() : Default constructor. ~ComponentBehavior() : Default destructor. void setupdate(std::function<void(Entity* entity)> update) : Sets the update function for the component. void Update(Entity* entity) : Updates the behavior of the entity. Private Members std::function<void(Entity* self)> _update_ : Function object representing the update function for the component. ComponentDraw Description The ComponentDraw class is a derived class of IComponent and represents the drawing component of an entity. It provides functionality for managing the position, size, scale, and texture ID of the entity's sprite. Public Members ComponentDraw(int X, int Y, int width, int height, int textureId) : Constructor that initializes the drawing component with the specified position, size, and texture ID. ~ComponentDraw() : Destructor. std::tuple<int, int> getX_Y() noexcept : Returns the X and Y coordinates of the drawing component. std::tuple<int, int> getHeightandWidth() noexcept : Returns the height and width of the drawing component. std::tuple<double, double> getScaleX_Y() noexcept : Returns the X and Y scale factors of the drawing component. int getTextureId() noexcept : Returns the texture ID of the drawing component. void setWidth(int width) noexcept : Sets the width of the drawing component. void setHeight(int height) noexcept : Sets the height of the drawing component. void setScale(float x, float y) noexcept : Sets the X and Y scale factors of the drawing component. void setTextureId(int textureId) noexcept : Sets the texture ID of the drawing component. Sprite& getSprite() noexcept : Returns a reference to the sprite associated with the drawing component. Private Members int _X : The X coordinate of the drawing component. int _Y : The Y coordinate of the drawing component. int _width : The width of the drawing component. int _heigth : The height of the drawing component. int _textureId : The texture ID of the drawing component. double _scaleX : The X scale factor of the drawing component. double _scaleY : The Y scale factor of the drawing component. Sprite sprite_ : The sprite associated with the drawing component. ComponentInput Description The ComponentInput class is a derived class of IComponent and represents the input component of an entity. It provides functionality for managing input values associated with the entity. Public Members ComponentInput() : Default constructor. ~ComponentInput() : Default destructor. void addInput(int input) noexcept : Adds an input value to the component. int getInput() noexcept : Returns the input value associated with the component. Private Members std::vector<int> _input : A vector storing the input values associated with the component. ComponentMouvement Description The ComponentMouvement class is a derived class of IComponent and represents the movement component of an entity. It provides functionality for managing the position and speed of the entity. Public Members ComponentMouvement(int X, int Y, double speed) : Constructor that initializes the movement component with the specified position and speed. ~ComponentMouvement() : Destructor. std::tuple<int, int> getXandY() noexcept : Returns the X and Y coordinates of the movement component. double getSpeed() noexcept : Returns the speed of the movement component. void setX(int X) noexcept : Sets the X coordinate of the movement component. void setY(int Y) noexcept : Sets the Y coordinate of the movement component. void setSpeed(double speed) noexcept : Sets the speed of the movement component. Private Members int _X : The X coordinate of the movement component. int _Y : The Y coordinate of the movement component. double _speed : The speed of the movement component. ComponentPosition Description The ComponentPosition class is a derived class of IComponent and represents the position component of an entity. It provides functionality for managing the position of the entity. Public Members ComponentPosition(int x, int y) noexcept : Constructor that initializes the position component with the specified coordinates. ~ComponentPosition() noexcept : Destructor. std::tuple<int, int> getXandY() const noexcept : Returns the X and Y coordinates of the position component. void setXandY(int x, int y) noexcept : Sets the X and Y coordinates of the position component. Protected Members int _x : The X coordinate of the position component. int _y : The Y coordinate of the position component. Please note that this documentation is based on the provided code snippets and may not cover all the details or context of the entire system. It is recommended to refer to the actual code implementation and any associated comments for a complete understanding.","title":"ECS Component"},{"location":"ecs_component/#componentbehavior","text":"Description The ComponentBehavior class is a derived class of IComponent and represents the behavior component of an entity. It provides functionality for updating the entity's behavior. Public Members ComponentBehavior() : Default constructor. ~ComponentBehavior() : Default destructor. void setupdate(std::function<void(Entity* entity)> update) : Sets the update function for the component. void Update(Entity* entity) : Updates the behavior of the entity. Private Members std::function<void(Entity* self)> _update_ : Function object representing the update function for the component.","title":"ComponentBehavior"},{"location":"ecs_component/#componentdraw","text":"Description The ComponentDraw class is a derived class of IComponent and represents the drawing component of an entity. It provides functionality for managing the position, size, scale, and texture ID of the entity's sprite. Public Members ComponentDraw(int X, int Y, int width, int height, int textureId) : Constructor that initializes the drawing component with the specified position, size, and texture ID. ~ComponentDraw() : Destructor. std::tuple<int, int> getX_Y() noexcept : Returns the X and Y coordinates of the drawing component. std::tuple<int, int> getHeightandWidth() noexcept : Returns the height and width of the drawing component. std::tuple<double, double> getScaleX_Y() noexcept : Returns the X and Y scale factors of the drawing component. int getTextureId() noexcept : Returns the texture ID of the drawing component. void setWidth(int width) noexcept : Sets the width of the drawing component. void setHeight(int height) noexcept : Sets the height of the drawing component. void setScale(float x, float y) noexcept : Sets the X and Y scale factors of the drawing component. void setTextureId(int textureId) noexcept : Sets the texture ID of the drawing component. Sprite& getSprite() noexcept : Returns a reference to the sprite associated with the drawing component. Private Members int _X : The X coordinate of the drawing component. int _Y : The Y coordinate of the drawing component. int _width : The width of the drawing component. int _heigth : The height of the drawing component. int _textureId : The texture ID of the drawing component. double _scaleX : The X scale factor of the drawing component. double _scaleY : The Y scale factor of the drawing component. Sprite sprite_ : The sprite associated with the drawing component.","title":"ComponentDraw"},{"location":"ecs_component/#componentinput","text":"Description The ComponentInput class is a derived class of IComponent and represents the input component of an entity. It provides functionality for managing input values associated with the entity. Public Members ComponentInput() : Default constructor. ~ComponentInput() : Default destructor. void addInput(int input) noexcept : Adds an input value to the component. int getInput() noexcept : Returns the input value associated with the component. Private Members std::vector<int> _input : A vector storing the input values associated with the component.","title":"ComponentInput"},{"location":"ecs_component/#componentmouvement","text":"Description The ComponentMouvement class is a derived class of IComponent and represents the movement component of an entity. It provides functionality for managing the position and speed of the entity. Public Members ComponentMouvement(int X, int Y, double speed) : Constructor that initializes the movement component with the specified position and speed. ~ComponentMouvement() : Destructor. std::tuple<int, int> getXandY() noexcept : Returns the X and Y coordinates of the movement component. double getSpeed() noexcept : Returns the speed of the movement component. void setX(int X) noexcept : Sets the X coordinate of the movement component. void setY(int Y) noexcept : Sets the Y coordinate of the movement component. void setSpeed(double speed) noexcept : Sets the speed of the movement component. Private Members int _X : The X coordinate of the movement component. int _Y : The Y coordinate of the movement component. double _speed : The speed of the movement component.","title":"ComponentMouvement"},{"location":"ecs_component/#componentposition","text":"Description The ComponentPosition class is a derived class of IComponent and represents the position component of an entity. It provides functionality for managing the position of the entity. Public Members ComponentPosition(int x, int y) noexcept : Constructor that initializes the position component with the specified coordinates. ~ComponentPosition() noexcept : Destructor. std::tuple<int, int> getXandY() const noexcept : Returns the X and Y coordinates of the position component. void setXandY(int x, int y) noexcept : Sets the X and Y coordinates of the position component. Protected Members int _x : The X coordinate of the position component. int _y : The Y coordinate of the position component. Please note that this documentation is based on the provided code snippets and may not cover all the details or context of the entire system. It is recommended to refer to the actual code implementation and any associated comments for a complete understanding.","title":"ComponentPosition"},{"location":"ecs_entity/","text":"Entity Description The Entity class represents an entity in a game or simulation. It is a container for components that define the properties and behaviors of the entity. Each entity has a unique identifier. Public Members Entity(size_t id) noexcept : Constructor that creates an entity with the specified identifier. ~Entity() noexcept : Destructor. size_t getIdex() noexcept : Returns the identifier of the entity. std::vector<std::shared_ptr<IComponent>>& getEntityComponent() noexcept : Returns a reference to the vector of components associated with the entity. template <typename T> void addComponent(T& component) noexcept : Adds a component of type T to the entity. template <typename T> T* getComponent() noexcept : Returns a pointer to the component of type T associated with the entity. template <typename T> int EntityhaveComponent() noexcept : Checks if the entity has a component of type T . template <typename T, typename... Args> bool hasComponents() noexcept : Checks if the entity has components of types T and Args... . Private Members std::vector<std::shared_ptr<IComponent>> _component : A vector of shared pointers to the components associated with the entity. size_t _id : The identifier of the entity. EntityManager Description The EntityManager class manages a collection of entities. It provides functionality for creating, accessing, and removing entities. Public Members EntityManager() noexcept : Default constructor. ~EntityManager() noexcept : Destructor. std::shared_ptr<Entity> CreateEntity() noexcept : Creates a new entity and returns a shared pointer to it. std::vector<std::shared_ptr<Entity>>& getEntity() noexcept : Returns a reference to the vector of entities managed by the entity manager. std::shared_ptr<Entity> findEntity(size_t id) noexcept : Finds an entity with the specified identifier and returns a shared pointer to it. int eraseEntity(size_t id) noexcept : Removes an entity with the specified identifier from the entity manager. Private Members std::vector<std::shared_ptr<Entity>> _entity : A vector of shared pointers to the entities managed by the entity manager. Please note that this documentation is based on the provided code snippets and may not cover all the details or context of the entire system. It is recommended to refer to the actual code implementation and any associated comments for a complete understanding.","title":"ECS Entity"},{"location":"ecs_entity/#entity","text":"Description The Entity class represents an entity in a game or simulation. It is a container for components that define the properties and behaviors of the entity. Each entity has a unique identifier. Public Members Entity(size_t id) noexcept : Constructor that creates an entity with the specified identifier. ~Entity() noexcept : Destructor. size_t getIdex() noexcept : Returns the identifier of the entity. std::vector<std::shared_ptr<IComponent>>& getEntityComponent() noexcept : Returns a reference to the vector of components associated with the entity. template <typename T> void addComponent(T& component) noexcept : Adds a component of type T to the entity. template <typename T> T* getComponent() noexcept : Returns a pointer to the component of type T associated with the entity. template <typename T> int EntityhaveComponent() noexcept : Checks if the entity has a component of type T . template <typename T, typename... Args> bool hasComponents() noexcept : Checks if the entity has components of types T and Args... . Private Members std::vector<std::shared_ptr<IComponent>> _component : A vector of shared pointers to the components associated with the entity. size_t _id : The identifier of the entity.","title":"Entity"},{"location":"ecs_entity/#entitymanager","text":"Description The EntityManager class manages a collection of entities. It provides functionality for creating, accessing, and removing entities. Public Members EntityManager() noexcept : Default constructor. ~EntityManager() noexcept : Destructor. std::shared_ptr<Entity> CreateEntity() noexcept : Creates a new entity and returns a shared pointer to it. std::vector<std::shared_ptr<Entity>>& getEntity() noexcept : Returns a reference to the vector of entities managed by the entity manager. std::shared_ptr<Entity> findEntity(size_t id) noexcept : Finds an entity with the specified identifier and returns a shared pointer to it. int eraseEntity(size_t id) noexcept : Removes an entity with the specified identifier from the entity manager. Private Members std::vector<std::shared_ptr<Entity>> _entity : A vector of shared pointers to the entities managed by the entity manager. Please note that this documentation is based on the provided code snippets and may not cover all the details or context of the entire system. It is recommended to refer to the actual code implementation and any associated comments for a complete understanding.","title":"EntityManager"},{"location":"ecs_system/","text":"SystemBehavior Description The SystemBehavior class is a component that represents a behavior system in a game or simulation. It inherits from the IComponent interface. It provides functionality for managing and executing behaviors associated with entities. Public Members SystemBehavior(EntityManager *entity) : Constructor that initializes the behavior system with a pointer to the EntityManager . ~SystemBehavior() : Destructor. void loop() : Performs the behavior system's main loop, where behaviors are executed. Private Members EntityManager *_entityManager : A pointer to the EntityManager that manages the entities associated with the behavior system. SystemDraw Description The SystemDraw class is responsible for drawing entities in a game or simulation. It provides functionality for rendering entities with visual components. Public Members SystemDraw(EntityManager *entity) : Constructor that initializes the drawing system with a pointer to the EntityManager . ~SystemDraw() : Destructor. void loop() : Performs the drawing system's main loop, where entities are rendered. void setWindow(Window* window) noexcept : Sets the window in which the entities will be drawn. Private Members Window *_window : A pointer to the window where entities will be drawn. EntityManager *_entity : A pointer to the EntityManager that manages the entities associated with the drawing system. SystemMouvement Description The SystemMouvement class is responsible for handling movement-related logic in a game or simulation. It provides functionality for updating the positions of entities with movement components. Public Members SystemMouvement(EntityManager *entity) : Constructor that initializes the movement system with a pointer to the EntityManager . ~SystemMouvement() : Destructor. void loop() : Performs the movement system's main loop, where entity positions are updated. Private Members EntityManager *_entity : A pointer to the EntityManager that manages the entities associated with the movement system. SystemMusic Description The SystemMusic class is a component that represents a music system in a game or simulation. It inherits from the IComponent interface. It provides functionality for managing and playing music associated with entities. Public Members SystemMusic(EntityManager *entity) : Constructor that initializes the music system with a pointer to the EntityManager . ~SystemMusic() : Destructor. void loop() : Performs the music system's main loop, where music is played. Private Members EntityManager *_entitymanager : A pointer to the EntityManager that manages the entities associated with the music system. SystemSound Description The SystemSound class is responsible for handling sound-related logic in a game or simulation. It provides functionality for playing sounds associated with entities. Public Members SystemSound(EntityManager *entitymanager) : Constructor that initializes the sound system with a pointer to the EntityManager . ~SystemSound() : Destructor. void loop() : Performs the sound system's main loop, where sounds are played. void setSoundManager(SoundManager* soundManager) noexcept : Sets the sound manager responsible for playing the sounds. Private Members EntityManager *_entitymanager : A pointer to the EntityManager that manages the entities associated with the sound system. SoundManager *soundManager_ : A pointer to the sound manager responsible for playing the sounds. Please note that this documentation is based on the provided code snippets and may not cover all the details or context of the entire system. It is recommended to refer to the actual code implementation and any associated comments for a complete understanding.","title":"ECS System"},{"location":"ecs_system/#systembehavior","text":"Description The SystemBehavior class is a component that represents a behavior system in a game or simulation. It inherits from the IComponent interface. It provides functionality for managing and executing behaviors associated with entities. Public Members SystemBehavior(EntityManager *entity) : Constructor that initializes the behavior system with a pointer to the EntityManager . ~SystemBehavior() : Destructor. void loop() : Performs the behavior system's main loop, where behaviors are executed. Private Members EntityManager *_entityManager : A pointer to the EntityManager that manages the entities associated with the behavior system.","title":"SystemBehavior"},{"location":"ecs_system/#systemdraw","text":"Description The SystemDraw class is responsible for drawing entities in a game or simulation. It provides functionality for rendering entities with visual components. Public Members SystemDraw(EntityManager *entity) : Constructor that initializes the drawing system with a pointer to the EntityManager . ~SystemDraw() : Destructor. void loop() : Performs the drawing system's main loop, where entities are rendered. void setWindow(Window* window) noexcept : Sets the window in which the entities will be drawn. Private Members Window *_window : A pointer to the window where entities will be drawn. EntityManager *_entity : A pointer to the EntityManager that manages the entities associated with the drawing system.","title":"SystemDraw"},{"location":"ecs_system/#systemmouvement","text":"Description The SystemMouvement class is responsible for handling movement-related logic in a game or simulation. It provides functionality for updating the positions of entities with movement components. Public Members SystemMouvement(EntityManager *entity) : Constructor that initializes the movement system with a pointer to the EntityManager . ~SystemMouvement() : Destructor. void loop() : Performs the movement system's main loop, where entity positions are updated. Private Members EntityManager *_entity : A pointer to the EntityManager that manages the entities associated with the movement system.","title":"SystemMouvement"},{"location":"ecs_system/#systemmusic","text":"Description The SystemMusic class is a component that represents a music system in a game or simulation. It inherits from the IComponent interface. It provides functionality for managing and playing music associated with entities. Public Members SystemMusic(EntityManager *entity) : Constructor that initializes the music system with a pointer to the EntityManager . ~SystemMusic() : Destructor. void loop() : Performs the music system's main loop, where music is played. Private Members EntityManager *_entitymanager : A pointer to the EntityManager that manages the entities associated with the music system.","title":"SystemMusic"},{"location":"ecs_system/#systemsound","text":"Description The SystemSound class is responsible for handling sound-related logic in a game or simulation. It provides functionality for playing sounds associated with entities. Public Members SystemSound(EntityManager *entitymanager) : Constructor that initializes the sound system with a pointer to the EntityManager . ~SystemSound() : Destructor. void loop() : Performs the sound system's main loop, where sounds are played. void setSoundManager(SoundManager* soundManager) noexcept : Sets the sound manager responsible for playing the sounds. Private Members EntityManager *_entitymanager : A pointer to the EntityManager that manages the entities associated with the sound system. SoundManager *soundManager_ : A pointer to the sound manager responsible for playing the sounds. Please note that this documentation is based on the provided code snippets and may not cover all the details or context of the entire system. It is recommended to refer to the actual code implementation and any associated comments for a complete understanding.","title":"SystemSound"},{"location":"error/","text":"Error Documentation Error Class Description The Error class is used to represent an error condition in the program. It provides a mechanism for storing and retrieving an error message. Header File #include \"../../include/Error/Error.hpp\" Constructors Error(std::string message) noexcept Constructs an Error object with the specified error message. Parameters: message : The error message to be displayed. Public Methods const char* what() const noexcept Returns a pointer to a C-style string that contains the error message. Example Usage #include \"../../include/Error/Error.hpp\" int main() { try { throw Error(\"An error occurred\"); } catch (const Error& e) { std::cout << \"Error message: \" << e.what() << std::endl; } return 0; } InitError Class Description The InitError class is a derived class of the Error class. It represents an error condition that occurs during initialization. Constructors InitError(std::string message) noexcept Constructs an InitError object with the specified error message. Parameters: message : The error message to be displayed. Example Usage #include \"../../include/Error/Error.hpp\" int main() { try { throw InitError(\"Initialization failed\"); } catch (const Error& e) { std::cout << \"Error message: \" << e.what() << std::endl; } return 0; } NetworkError Class Description The NetworkError class is a derived class of the Error class. It represents an error condition that occurs during network operations. Constructors NetworkError(std::string message) noexcept Constructs a NetworkError object with the specified error message. Parameters: message : The error message to be displayed. Example Usage #include \"../../include/Error/Error.hpp\" int main() { try { throw NetworkError(\"Network error occurred\"); } catch (const Error& e) { std::cout << \"Error message: \" << e.what() << std::endl; } return 0; } Note: The above examples assume that the necessary header files and libraries are included and linked properly.","title":"Error Game"},{"location":"error/#error-documentation","text":"","title":"Error Documentation"},{"location":"error/#error-class","text":"","title":"Error Class"},{"location":"error/#description","text":"The Error class is used to represent an error condition in the program. It provides a mechanism for storing and retrieving an error message.","title":"Description"},{"location":"error/#header-file","text":"#include \"../../include/Error/Error.hpp\"","title":"Header File"},{"location":"error/#constructors","text":"","title":"Constructors"},{"location":"error/#errorstdstring-message-noexcept","text":"Constructs an Error object with the specified error message. Parameters: message : The error message to be displayed.","title":"Error(std::string message) noexcept"},{"location":"error/#public-methods","text":"","title":"Public Methods"},{"location":"error/#const-char-what-const-noexcept","text":"Returns a pointer to a C-style string that contains the error message.","title":"const char* what() const noexcept"},{"location":"error/#example-usage","text":"#include \"../../include/Error/Error.hpp\" int main() { try { throw Error(\"An error occurred\"); } catch (const Error& e) { std::cout << \"Error message: \" << e.what() << std::endl; } return 0; }","title":"Example Usage"},{"location":"error/#initerror-class","text":"","title":"InitError Class"},{"location":"error/#description_1","text":"The InitError class is a derived class of the Error class. It represents an error condition that occurs during initialization.","title":"Description"},{"location":"error/#constructors_1","text":"","title":"Constructors"},{"location":"error/#initerrorstdstring-message-noexcept","text":"Constructs an InitError object with the specified error message. Parameters: message : The error message to be displayed.","title":"InitError(std::string message) noexcept"},{"location":"error/#example-usage_1","text":"#include \"../../include/Error/Error.hpp\" int main() { try { throw InitError(\"Initialization failed\"); } catch (const Error& e) { std::cout << \"Error message: \" << e.what() << std::endl; } return 0; }","title":"Example Usage"},{"location":"error/#networkerror-class","text":"","title":"NetworkError Class"},{"location":"error/#description_2","text":"The NetworkError class is a derived class of the Error class. It represents an error condition that occurs during network operations.","title":"Description"},{"location":"error/#constructors_2","text":"","title":"Constructors"},{"location":"error/#networkerrorstdstring-message-noexcept","text":"Constructs a NetworkError object with the specified error message. Parameters: message : The error message to be displayed.","title":"NetworkError(std::string message) noexcept"},{"location":"error/#example-usage_2","text":"#include \"../../include/Error/Error.hpp\" int main() { try { throw NetworkError(\"Network error occurred\"); } catch (const Error& e) { std::cout << \"Error message: \" << e.what() << std::endl; } return 0; } Note: The above examples assume that the necessary header files and libraries are included and linked properly.","title":"Example Usage"},{"location":"game_server/","text":"Server Documentation Introduction The Server class represents a server that listens for client connections, receives and sends data to clients, and runs a game loop. It provides functions to start and stop the server, handle client communication, and manage client connections. Public Member Functions Server(Address::Port port) The constructor of the Server class. It creates a socket and a selector, adds the socket to the selector, and starts the game and network threads. Parameters: - port : The port to listen on. void stop() noexcept Stops the server. It sets the looping_ flag to false, which will cause the server to exit the game and network loops. void reset() noexcept Resets the server to its initial state. It sets the looping_ flag to true. void run() The run function joins the game and network threads. It waits for both threads to finish before returning. Private Member Functions void communicate() noexcept The communicate function is responsible forhandling client communication. It waits for a client to connect, then waits for a client to send a message, then sends a message to the client, and finally checks if the client is still connected. void gameLoop() noexcept The gameLoop function runs the game loop and sends the data to the clients. It is responsible for updating the game state and sending the updated state to all connected clients. void receive() The receive function receives data from the client and handles it. It checks if the client is known to the server, and if not, it adds the client to the list of connected clients. It then handles the data received from the client. void send() noexcept The send function sends data to the clients. If there is data to send in the send queue, it sends the data to the respective clients. void sendToClient(Client& client, RawData blob) The sendToClient function sends a blob of data to a client. It takes the client object and the data to send as parameters. RawData getDataFromQueue(Client& client) noexcept The getDataFromQueue function retrieves the first element from the send queue of a client and returns it. It takes the client object as a parameter. void handleData(ReceivedInfos infos) noexcept The handleData function handles the data received from the client. It takes a struct containing the address of the client and the received data as a parameter. bool isKnownClient(Address address) const The isKnownClient function checks if a client with the given address is known to the server. It returns true if the client is known, and false otherwise. void addClient(Address address, std::chrono::high_resolution_clock::time_point ping) noexcept The addClient function adds a new client to the server. It takes the address of the client and the time the client sent the ping as parameters. void removeClient(Address& clientAddress) noexcept The removeClient function removes a client from the server. It takes the address of the client to remove as a parameter. void areClientsConnected() noexcept The areClientsConnected function checks if clients are still connected to the server. If a client hasn't sent a ping in a while, it sends a ping to the client. If the client doesn't respond to the ping, it disconnects the client. void updateClientState(Address& clientAddress, bool isPing) noexcept The updateClientState function updates the state of a client based on the received message. If the client is found in the list of clients, it sets the isPingSent flag to false. If the client sent a ping, it sends a pong back. Member Variables The Server class has several private member variables that are used to manage client connections and handle communication: socket_ : An instance of the socket class used for server communication. selector_ : An instance of the selector class used to monitor multiple sockets for activity. clients_ : A vector of client objects representing the connected clients. sendQueue_ : A queue of data to be sent to the clients. looping_ : A boolean flag indicating whether the server is running or stopped. If looping_ is true, the server is running, and if looping_ is false, the server is stopped. These member variables are used internally by the server to manage client connections, handle communication, and run the game loop.","title":"Game Serveur"},{"location":"game_server/#server-documentation","text":"Introduction The Server class represents a server that listens for client connections, receives and sends data to clients, and runs a game loop. It provides functions to start and stop the server, handle client communication, and manage client connections.","title":"Server Documentation"},{"location":"game_server/#public-member-functions","text":"","title":"Public Member Functions"},{"location":"game_server/#serveraddressport-port","text":"The constructor of the Server class. It creates a socket and a selector, adds the socket to the selector, and starts the game and network threads. Parameters: - port : The port to listen on.","title":"Server(Address::Port port)"},{"location":"game_server/#void-stop-noexcept","text":"Stops the server. It sets the looping_ flag to false, which will cause the server to exit the game and network loops.","title":"void stop() noexcept"},{"location":"game_server/#void-reset-noexcept","text":"Resets the server to its initial state. It sets the looping_ flag to true.","title":"void reset() noexcept"},{"location":"game_server/#void-run","text":"The run function joins the game and network threads. It waits for both threads to finish before returning.","title":"void run()"},{"location":"game_server/#private-member-functions","text":"","title":"Private Member Functions"},{"location":"game_server/#void-communicate-noexcept","text":"The communicate function is responsible forhandling client communication. It waits for a client to connect, then waits for a client to send a message, then sends a message to the client, and finally checks if the client is still connected.","title":"void communicate() noexcept"},{"location":"game_server/#void-gameloop-noexcept","text":"The gameLoop function runs the game loop and sends the data to the clients. It is responsible for updating the game state and sending the updated state to all connected clients.","title":"void gameLoop() noexcept"},{"location":"game_server/#void-receive","text":"The receive function receives data from the client and handles it. It checks if the client is known to the server, and if not, it adds the client to the list of connected clients. It then handles the data received from the client.","title":"void receive()"},{"location":"game_server/#void-send-noexcept","text":"The send function sends data to the clients. If there is data to send in the send queue, it sends the data to the respective clients.","title":"void send() noexcept"},{"location":"game_server/#void-sendtoclientclient-client-rawdata-blob","text":"The sendToClient function sends a blob of data to a client. It takes the client object and the data to send as parameters.","title":"void sendToClient(Client&amp; client, RawData blob)"},{"location":"game_server/#rawdata-getdatafromqueueclient-client-noexcept","text":"The getDataFromQueue function retrieves the first element from the send queue of a client and returns it. It takes the client object as a parameter.","title":"RawData getDataFromQueue(Client&amp; client) noexcept"},{"location":"game_server/#void-handledatareceivedinfos-infos-noexcept","text":"The handleData function handles the data received from the client. It takes a struct containing the address of the client and the received data as a parameter.","title":"void handleData(ReceivedInfos infos) noexcept"},{"location":"game_server/#bool-isknownclientaddress-address-const","text":"The isKnownClient function checks if a client with the given address is known to the server. It returns true if the client is known, and false otherwise.","title":"bool isKnownClient(Address address) const"},{"location":"game_server/#void-addclientaddress-address-stdchronohigh_resolution_clocktime_point-ping-noexcept","text":"The addClient function adds a new client to the server. It takes the address of the client and the time the client sent the ping as parameters.","title":"void addClient(Address address, std::chrono::high_resolution_clock::time_point ping) noexcept"},{"location":"game_server/#void-removeclientaddress-clientaddress-noexcept","text":"The removeClient function removes a client from the server. It takes the address of the client to remove as a parameter.","title":"void removeClient(Address&amp; clientAddress) noexcept"},{"location":"game_server/#void-areclientsconnected-noexcept","text":"The areClientsConnected function checks if clients are still connected to the server. If a client hasn't sent a ping in a while, it sends a ping to the client. If the client doesn't respond to the ping, it disconnects the client.","title":"void areClientsConnected() noexcept"},{"location":"game_server/#void-updateclientstateaddress-clientaddress-bool-isping-noexcept","text":"The updateClientState function updates the state of a client based on the received message. If the client is found in the list of clients, it sets the isPingSent flag to false. If the client sent a ping, it sends a pong back.","title":"void updateClientState(Address&amp; clientAddress, bool isPing) noexcept"},{"location":"game_server/#member-variables","text":"The Server class has several private member variables that are used to manage client connections and handle communication: socket_ : An instance of the socket class used for server communication. selector_ : An instance of the selector class used to monitor multiple sockets for activity. clients_ : A vector of client objects representing the connected clients. sendQueue_ : A queue of data to be sent to the clients. looping_ : A boolean flag indicating whether the server is running or stopped. If looping_ is true, the server is running, and if looping_ is false, the server is stopped. These member variables are used internally by the server to manage client connections, handle communication, and run the game loop.","title":"Member Variables"},{"location":"json_tool/","text":"JsonTools Documentation Description The JsonTools class provides methods for working with JSON files and objects. It includes a method for reading a JSON file and returning the JSON object. Header File #include \"../../include/Json/JsonTools.hpp\" Public Methods json getPatternsFromFile() Reads a JSON file and returns the JSON object. Parameters: None Return Value: A JSON object representing the contents of the file. Example Usage #include \"../../include/Json/JsonTools.hpp\" int main() { JsonTools jsonTools; // Read a JSON file and get the JSON object json patterns = jsonTools.getPatternsFromFile(); // Print the JSON object std::cout << patterns.dump(4) << std::endl; return 0; } Note: The above example assumes that the necessary header files and libraries are included and linked properly, and that the JSON file exists at the specified path.","title":"Json Tools"},{"location":"json_tool/#jsontools-documentation","text":"Description The JsonTools class provides methods for working with JSON files and objects. It includes a method for reading a JSON file and returning the JSON object.","title":"JsonTools Documentation"},{"location":"json_tool/#header-file","text":"#include \"../../include/Json/JsonTools.hpp\"","title":"Header File"},{"location":"json_tool/#public-methods","text":"json getPatternsFromFile() Reads a JSON file and returns the JSON object. Parameters: None Return Value: A JSON object representing the contents of the file.","title":"Public Methods"},{"location":"json_tool/#example-usage","text":"#include \"../../include/Json/JsonTools.hpp\" int main() { JsonTools jsonTools; // Read a JSON file and get the JSON object json patterns = jsonTools.getPatternsFromFile(); // Print the JSON object std::cout << patterns.dump(4) << std::endl; return 0; } Note: The above example assumes that the necessary header files and libraries are included and linked properly, and that the JSON file exists at the specified path.","title":"Example Usage"},{"location":"lib_client/","text":"Lib Client The provided code consists of several C++ class definitions. Here's a brief explanation of each class: Buffer This class represents a sound buffer. It uses the SFML library's sf::SoundBuffer to load and store audio data from a file. The Buffer class has a private member mybuffer of type sf::SoundBuffer and a public member function getSoundBuffer() that returns a reference to the sound buffer. Lib This class represents a library and contains a Window object named lafenetre. It provides a member function getWindow() to access the Window object. Music This class represents a music player. It uses the SFML library's sf::Music to load and play music from a file. The Music class has private members mymusic_path to store the path of the music file and mymusic as a shared pointer to sf::Music. It provides member functions to control the playback of the music, such as play(), pause(), stop(), setVolume(), setLoop(), etc. SoundManager This class manages multiple sound buffers. It has private members buffers_ and buffersPaths_ to store instances of the Buffer class and their corresponding file paths. It provides member functions to add sound buffers and retrieve a buffer based on its path. Sound This class represents a sound player. It uses the SFML library's sf::Sound to play sounds using a sound buffer. The Sound class has a private member mysound of type sf::Sound and a std::string member soundPath to store the path of the sound file. It provides member functions to control the playback of the sound, such as play(), pause(), stop(), setVolume(), etc. Sprite This class represents a sprite, which is an image that can be displayed on the screen. It uses the SFML library's sf::Sprite and sf::Texture classes to load and display the sprite image. The Sprite class has private members spritePath to store the path of the sprite image file, coordx and coordy to store the position of the sprite, sprite of type sf::Sprite to represent the sprite, and texture_sprite of type sf::Texture to store the texture of the sprite. It provides member functions to set and retrieve the properties of the sprite, such as setSpritePath(), getX(), getY(), etc. Text This class represents text that can be displayed on the screen. It uses the SFML library's sf::Text and sf::Font classes to load and display the text. The Text class has private members mytext of type sf::Text to store the text object, myfont of type sf::Font to store the font used for the text, coordx and coordy to store the position of the text, and mycolor of type sf::Color to store the color of the text. It provides member functions to set and retrieve the properties of the text, such as setTextString(), setFontPath(), setFontSize(), getX(), getY(), etc. These classes can be used to create and manipulate audio, visual, and text elements in a C++ program using the SFML library.","title":"Library Client"},{"location":"lib_client/#lib-client","text":"The provided code consists of several C++ class definitions. Here's a brief explanation of each class:","title":"Lib Client"},{"location":"lib_client/#buffer","text":"This class represents a sound buffer. It uses the SFML library's sf::SoundBuffer to load and store audio data from a file. The Buffer class has a private member mybuffer of type sf::SoundBuffer and a public member function getSoundBuffer() that returns a reference to the sound buffer.","title":"Buffer"},{"location":"lib_client/#lib","text":"This class represents a library and contains a Window object named lafenetre. It provides a member function getWindow() to access the Window object.","title":"Lib"},{"location":"lib_client/#music","text":"This class represents a music player. It uses the SFML library's sf::Music to load and play music from a file. The Music class has private members mymusic_path to store the path of the music file and mymusic as a shared pointer to sf::Music. It provides member functions to control the playback of the music, such as play(), pause(), stop(), setVolume(), setLoop(), etc.","title":"Music"},{"location":"lib_client/#soundmanager","text":"This class manages multiple sound buffers. It has private members buffers_ and buffersPaths_ to store instances of the Buffer class and their corresponding file paths. It provides member functions to add sound buffers and retrieve a buffer based on its path.","title":"SoundManager"},{"location":"lib_client/#sound","text":"This class represents a sound player. It uses the SFML library's sf::Sound to play sounds using a sound buffer. The Sound class has a private member mysound of type sf::Sound and a std::string member soundPath to store the path of the sound file. It provides member functions to control the playback of the sound, such as play(), pause(), stop(), setVolume(), etc.","title":"Sound"},{"location":"lib_client/#sprite","text":"This class represents a sprite, which is an image that can be displayed on the screen. It uses the SFML library's sf::Sprite and sf::Texture classes to load and display the sprite image. The Sprite class has private members spritePath to store the path of the sprite image file, coordx and coordy to store the position of the sprite, sprite of type sf::Sprite to represent the sprite, and texture_sprite of type sf::Texture to store the texture of the sprite. It provides member functions to set and retrieve the properties of the sprite, such as setSpritePath(), getX(), getY(), etc.","title":"Sprite"},{"location":"lib_client/#text","text":"This class represents text that can be displayed on the screen. It uses the SFML library's sf::Text and sf::Font classes to load and display the text. The Text class has private members mytext of type sf::Text to store the text object, myfont of type sf::Font to store the font used for the text, coordx and coordy to store the position of the text, and mycolor of type sf::Color to store the color of the text. It provides member functions to set and retrieve the properties of the text, such as setTextString(), setFontPath(), setFontSize(), getX(), getY(), etc. These classes can be used to create and manipulate audio, visual, and text elements in a C++ program using the SFML library.","title":"Text"},{"location":"present/","text":"Welcome to R-TYPE The goal is to implement a multithreaded server and a graphical client for a well-known legacy video game called R-Type, using a game engine of your own design. Language: Advanced C++ Build tool The project must be built using a CMake and dependencies must be handled using conan. Graphique We used SFML for client-side displays and all rendering was done using SFML. Network The network library is the package that enables the various clients to communicate with the server and play with their friends. The principle is simple: you connect via TCP, which manages several game servers using the UDP protocol. The client is then directly redirected to an available game server and switches to UDP communication to play.","title":"Home"},{"location":"present/#welcome-to-r-type","text":"The goal is to implement a multithreaded server and a graphical client for a well-known legacy video game called R-Type, using a game engine of your own design. Language: Advanced C++","title":"Welcome to R-TYPE"},{"location":"present/#build-tool","text":"The project must be built using a CMake and dependencies must be handled using conan.","title":"Build tool"},{"location":"present/#graphique","text":"We used SFML for client-side displays and all rendering was done using SFML.","title":"Graphique"},{"location":"present/#network","text":"The network library is the package that enables the various clients to communicate with the server and play with their friends. The principle is simple: you connect via TCP, which manages several game servers using the UDP protocol. The client is then directly redirected to an available game server and switches to UDP communication to play.","title":"Network"},{"location":"readmi/","text":"About the project This project aims to recreate the cross-platform video game R-Type with an online mutiplayer mode. It required the implementation of a multithreaded server and a graphical client, using an engine of our own design. Tools: Project made in C++ version 20 use of the SFML graphical library to display game elements Compiled with CMake , minimum version required : 3.17 GITHUB Actions for automatique tests MK Docs for documentation A Script is provided to compile, run and test the project Some of the features we implemented: A multithreaded server, to handle communication and game logic at the same time A generic Entity Component System architecture and game engine A graphical client, to display the game and handle user input A client-server communication protocol A network building with ENet for the connection Build tool The project must be built using a CMake and dependencies must be handled using conan. Installation Tools: Ensure that you have cmake and enet installed in your pc Linux: ./run.sh Graphique We used SFML for client-side displays and all rendering was done using SFML. Network The network library is the package that enables the various clients to communicate with the server and play with their friends. How to play Once the game is launched, we enter the server's IP address and the port it is connected to. Then, the game can begin. To move the player upwards , we use the directional key: up . To move the player downwards , we use the directional key: down . To move the player to the right , we use the directional key: right . To move the player to the left , we use the directional key: left . To shoot , we use the key: space . To spawn enemies, we use the key: enter . UML Serveur: Architecture Client: Architecture Entity: Architecture Components: Architecture System: Architecture Game improvements Want to create your own custom levels ? Check out our Level's guide ! Licence MTI Licence Copyright (c) 2012-2023 Scott Chacon and others Licence","title":"Readme"},{"location":"readmi/#about-the-project","text":"This project aims to recreate the cross-platform video game R-Type with an online mutiplayer mode. It required the implementation of a multithreaded server and a graphical client, using an engine of our own design. Tools: Project made in C++ version 20 use of the SFML graphical library to display game elements Compiled with CMake , minimum version required : 3.17 GITHUB Actions for automatique tests MK Docs for documentation A Script is provided to compile, run and test the project Some of the features we implemented: A multithreaded server, to handle communication and game logic at the same time A generic Entity Component System architecture and game engine A graphical client, to display the game and handle user input A client-server communication protocol A network building with ENet for the connection","title":"About the project"},{"location":"readmi/#build-tool","text":"The project must be built using a CMake and dependencies must be handled using conan.","title":"Build tool"},{"location":"readmi/#installation","text":"Tools: Ensure that you have cmake and enet installed in your pc Linux: ./run.sh","title":"Installation"},{"location":"readmi/#graphique","text":"We used SFML for client-side displays and all rendering was done using SFML.","title":"Graphique"},{"location":"readmi/#network","text":"The network library is the package that enables the various clients to communicate with the server and play with their friends.","title":"Network"},{"location":"readmi/#how-to-play","text":"Once the game is launched, we enter the server's IP address and the port it is connected to. Then, the game can begin. To move the player upwards , we use the directional key: up . To move the player downwards , we use the directional key: down . To move the player to the right , we use the directional key: right . To move the player to the left , we use the directional key: left . To shoot , we use the key: space . To spawn enemies, we use the key: enter .","title":"How to play"},{"location":"readmi/#uml","text":"Serveur: Architecture Client: Architecture Entity: Architecture Components: Architecture System: Architecture","title":"UML"},{"location":"readmi/#game-improvements","text":"Want to create your own custom levels ? Check out our Level's guide !","title":"Game improvements"},{"location":"readmi/#licence","text":"MTI Licence Copyright (c) 2012-2023 Scott Chacon and others Licence","title":"Licence"},{"location":"rfcprotocole/","text":"Protocole RFC This note is the official specification for the two R-Type protocols (the R-Type TCP protocol and the R-Type UDP protocol). Introduction The aim of the R-Type project is to create an online multiplayer copy of the classic multiplayer online game R-Type (1987). R-Type architecture R-Type's architecture is a classic client-server game architecture architecture. The entire game engine is located in the server. A client connects connects to the server using the R-Type TCP protocol. Once connected, the client can choose between creating a new lobby or joining an existing one. Several clients can connect to the server at the same time. Next, the customer who created the lobby can start a new game. The server can run several games at the same time. R-Type TCP Protocol All client-server communication prior to game launch is carried out using this using this R-type TCP protocol. These codes define the different actions that we will observe at the with the action assigned to each function. The ACTION enumeration: enum ACTION { 500 = KO, 230 = CONNECT, 332 = JOIN, 201 = READY, 200 = START, 221 = DECONNECTION, 250 = MOVE, 257 = SHOOT, 530 = QUIT, 211 = LEFT, 212 = RIGHT, 213 = UP, 214 = DOWN }; To send a payload, each piece of data must be written to the socket so that the actions behind it can be executed. Code explanations To explain what's going on, we need to understand that these different codes have a very precise meaning for the customer. In this way, the customer relies on these various codes to respond to the instructions. 500 = KO : This allows the customer to understand that the message has not not reached its destination. So there's an error in the message reception 230 = connect : This tells the client that it has successfully connected to the server, enabling further communication. 332 = join : This allows you to manage the integration of a new a new player into an existing or exixtante game. 201 = ready : This code is used to recognize at customer level whether a party has started. 221 = deconnection : From its name with the code, this lets us know that the client server has been disconnected. 250 = move : This code lets the customer know that there is an entity entity performing a movement. 257 = shoot : This code can be used to identify interactions between player and enemy interactions. 530 = quit : This code, when sent, lets the customer know to know that it must completely disconnect from the client. 211 = left : This code allows us to identify that the entity moves to the left. 212 = right : This code allows us to identify that the entity moves to the right. 213 = up : This code allows us to identify that the entity is moving upwards. 214 = down : This code allows us to identify that the entity is moving downwards. Once the server has received these different codes, it knows exactly what action to execute. This ensures a smooth collision between the different entities in the game. Reception at the server's After sending these different codes, the server receives them and then goes on to process the retrieved information. With these codes, the waiter would know what to do with his level. And this is how it reacts to the different codes. When the server receives: 500 : This tells the server that there has been a connection problem. 230 : This code notifies the customer that the connection has been been established. 332 : This tells the server that an entity has joined a player group or a new game. 201 : This enables the server to create the entities required to generate a game. 221 : When this code is sent to the server level, the latter deletes the entities to end the game. 250 : On seeing this code, the server increments the position of the entity. 257 : Once this code has been sent to the server, the latter activates the entity responsible for managing in-game shooting events 530 : The latter lets the server know that it's time to to break the connection with the client. 211 : This allows the server to move the moving entity left on the abssice axis. 212 : This allows the server to move the moving entity right on the abssice axis. 213 : Cela permet au serveur d\u00e9plac\u00e9 l'entit\u00e9 en mouvement vers la haut sur l'axe de ordonn\u00e9. 214 : This allows the server to move the moving entity down the order axis. Finally, we need to understand that it's these different codes that server and client to communicate with each other. So we can quickly detect problems.","title":"Protocole RFC"},{"location":"rfcprotocole/#protocole-rfc","text":"This note is the official specification for the two R-Type protocols (the R-Type TCP protocol and the R-Type UDP protocol). Introduction The aim of the R-Type project is to create an online multiplayer copy of the classic multiplayer online game R-Type (1987).","title":"Protocole RFC"},{"location":"rfcprotocole/#r-type-architecture","text":"R-Type's architecture is a classic client-server game architecture architecture. The entire game engine is located in the server. A client connects connects to the server using the R-Type TCP protocol. Once connected, the client can choose between creating a new lobby or joining an existing one. Several clients can connect to the server at the same time. Next, the customer who created the lobby can start a new game. The server can run several games at the same time.","title":"R-Type architecture"},{"location":"rfcprotocole/#r-type-tcp-protocol","text":"All client-server communication prior to game launch is carried out using this using this R-type TCP protocol. These codes define the different actions that we will observe at the with the action assigned to each function. The ACTION enumeration: enum ACTION { 500 = KO, 230 = CONNECT, 332 = JOIN, 201 = READY, 200 = START, 221 = DECONNECTION, 250 = MOVE, 257 = SHOOT, 530 = QUIT, 211 = LEFT, 212 = RIGHT, 213 = UP, 214 = DOWN }; To send a payload, each piece of data must be written to the socket so that the actions behind it can be executed.","title":"R-Type TCP Protocol"},{"location":"rfcprotocole/#code-explanations","text":"To explain what's going on, we need to understand that these different codes have a very precise meaning for the customer. In this way, the customer relies on these various codes to respond to the instructions. 500 = KO : This allows the customer to understand that the message has not not reached its destination. So there's an error in the message reception 230 = connect : This tells the client that it has successfully connected to the server, enabling further communication. 332 = join : This allows you to manage the integration of a new a new player into an existing or exixtante game. 201 = ready : This code is used to recognize at customer level whether a party has started. 221 = deconnection : From its name with the code, this lets us know that the client server has been disconnected. 250 = move : This code lets the customer know that there is an entity entity performing a movement. 257 = shoot : This code can be used to identify interactions between player and enemy interactions. 530 = quit : This code, when sent, lets the customer know to know that it must completely disconnect from the client. 211 = left : This code allows us to identify that the entity moves to the left. 212 = right : This code allows us to identify that the entity moves to the right. 213 = up : This code allows us to identify that the entity is moving upwards. 214 = down : This code allows us to identify that the entity is moving downwards. Once the server has received these different codes, it knows exactly what action to execute. This ensures a smooth collision between the different entities in the game.","title":"Code explanations"},{"location":"rfcprotocole/#reception-at-the-servers","text":"After sending these different codes, the server receives them and then goes on to process the retrieved information. With these codes, the waiter would know what to do with his level. And this is how it reacts to the different codes. When the server receives: 500 : This tells the server that there has been a connection problem. 230 : This code notifies the customer that the connection has been been established. 332 : This tells the server that an entity has joined a player group or a new game. 201 : This enables the server to create the entities required to generate a game. 221 : When this code is sent to the server level, the latter deletes the entities to end the game. 250 : On seeing this code, the server increments the position of the entity. 257 : Once this code has been sent to the server, the latter activates the entity responsible for managing in-game shooting events 530 : The latter lets the server know that it's time to to break the connection with the client. 211 : This allows the server to move the moving entity left on the abssice axis. 212 : This allows the server to move the moving entity right on the abssice axis. 213 : Cela permet au serveur d\u00e9plac\u00e9 l'entit\u00e9 en mouvement vers la haut sur l'axe de ordonn\u00e9. 214 : This allows the server to move the moving entity down the order axis. Finally, we need to understand that it's these different codes that server and client to communicate with each other. So we can quickly detect problems.","title":"Reception at the server's"},{"location":"serialisez/","text":"Serializer Documentation Description The Serializer class provides methods for serializing data into a vector of bytes. It includes methods for serializing entity components, music components, and key codes. Header File #include \"../../include/Serializer/Serializer.hpp\" Public Methods RawData serialize(std::unique_ptr\\<Entity> const& entity, std::vector\\<Player> players_) noexcept Serializes the position and drawable components of an entity into a vector of bytes. Parameters: entity : A unique pointer to the entity to be serialized. players_ : A vector of players. Return Value: A vector of uint8_t representing the serialized data. RawData serializeMusic(std::unique_ptr\\<Entity> const& entity) noexcept Serializes the sound component of an entity into a vector of bytes. Parameters: entity : A unique pointer to the entity to be serialized. Return Value: A vector of uint8_t representing the serialized data. RawData serialize(int keyCode) Serializes an integer into a vector of bytes. Parameters: keyCode : The key code to be serialized. Return Value: A vector of uint8_t representing the serialized data. Example Usage #include \"../../include/Serializer/Serializer.hpp\" int main() { Serializer serializer; std::unique_ptr<Entity> entity = std::make_unique<Entity>(); // Serialize entity components RawData serializedData = serializer.serialize(entity, players_); // Serialize music component RawData musicData = serializer.serializeMusic(entity); // Serialize key code RawData keyCodeData = serializer.serialize(65); return 0; } Note: The above example assumes that the necessary header files and libraries are included and linked properly, and that the players_ vector and the Entity object are properly defined and initialized.","title":"Serializer"},{"location":"serialisez/#serializer-documentation","text":"Description The Serializer class provides methods for serializing data into a vector of bytes. It includes methods for serializing entity components, music components, and key codes.","title":"Serializer Documentation"},{"location":"serialisez/#header-file","text":"#include \"../../include/Serializer/Serializer.hpp\"","title":"Header File"},{"location":"serialisez/#public-methods","text":"","title":"Public Methods"},{"location":"serialisez/#rawdata-serializestdunique_ptrentity-const-entity-stdvectorplayer-players_-noexcept","text":"Serializes the position and drawable components of an entity into a vector of bytes. Parameters: entity : A unique pointer to the entity to be serialized. players_ : A vector of players. Return Value: A vector of uint8_t representing the serialized data.","title":"RawData serialize(std::unique_ptr\\&lt;Entity> const&amp; entity, std::vector\\&lt;Player> players_) noexcept"},{"location":"serialisez/#rawdata-serializemusicstdunique_ptrentity-const-entity-noexcept","text":"Serializes the sound component of an entity into a vector of bytes. Parameters: entity : A unique pointer to the entity to be serialized. Return Value: A vector of uint8_t representing the serialized data.","title":"RawData serializeMusic(std::unique_ptr\\&lt;Entity> const&amp; entity) noexcept"},{"location":"serialisez/#rawdata-serializeint-keycode","text":"Serializes an integer into a vector of bytes. Parameters: keyCode : The key code to be serialized. Return Value: A vector of uint8_t representing the serialized data.","title":"RawData serialize(int keyCode)"},{"location":"serialisez/#example-usage","text":"#include \"../../include/Serializer/Serializer.hpp\" int main() { Serializer serializer; std::unique_ptr<Entity> entity = std::make_unique<Entity>(); // Serialize entity components RawData serializedData = serializer.serialize(entity, players_); // Serialize music component RawData musicData = serializer.serializeMusic(entity); // Serialize key code RawData keyCodeData = serializer.serialize(65); return 0; } Note: The above example assumes that the necessary header files and libraries are included and linked properly, and that the players_ vector and the Entity object are properly defined and initialized.","title":"Example Usage"},{"location":"serveur/","text":"Class ENetServer The ENetServer class is responsible for creating and managing an ENet server using the ENet library for network communication. Methods ENetServer() The constructor of the ENetServer class initializes the ENet library by calling the enet_initialize() function. If initialization fails, an error is printed, and the program exits with a EXIT_FAILURE exit code. * ~ENetServer() The destructor of the ENetServer class releases the resources used by the ENet library by calling the enet_deinitialize() function. startServer(int port) The startServer method starts the ENet server. It takes an integer port parameter that specifies the port number on which the server should listen for incoming connections. The method performs the following operations: Initializes an ENetAddress structure with the server's IP address (in this example, \"10.50.6.84\") and the port number passed as a parameter. Creates an ENet host using the enet_host_create() function with the address and additional parameters (32 channels, 2 incoming connections, no outgoing bandwidth limit, no incoming bandwidth limit). If the host creation fails, an error is printed, and the program exits with a EXIT_FAILURE exit code. run() The run method is responsible for the main execution of the server. It uses an infinite while loop to wait for and handle network events. The method performs the following operations: Waits for a network event using the enet_host_service() function. If an event is received, it is processed based on its type: ENET_EVENT_TYPE_CONNECT: Prints a message indicating that a client has connected. ENET_EVENT_TYPE_RECEIVE: Prints a message indicating that a packet has been received from the client, then destroys the packet using the enet_packet_destroy() function. ENET_EVENT_TYPE_DISCONNECT: Prints a message indicating that a client has disconnected. The loop continues to wait for new events. stopServer() The stopServer method stops the ENet server by destroying the ENet host using the enet_host_destroy() function. main() function The main function is the entry point of the program. It creates an instance of the ENetServer class, starts the server by calling the startServer() method with the port number passed as a command-line argument (av[1]), and runs the server by calling the run() method. Finally, the main function returns 0 to indicate successful execution. Please note that to use this code, you need to include the \"Serveur.hpp\" header file and the ENet library using #include . Also, make sure you have the ENet library installed and properly configured.","title":"ENet Server"},{"location":"serveur/#class-enetserver","text":"The ENetServer class is responsible for creating and managing an ENet server using the ENet library for network communication.","title":"Class ENetServer"},{"location":"serveur/#methods","text":"ENetServer() The constructor of the ENetServer class initializes the ENet library by calling the enet_initialize() function. If initialization fails, an error is printed, and the program exits with a EXIT_FAILURE exit code. * ~ENetServer() The destructor of the ENetServer class releases the resources used by the ENet library by calling the enet_deinitialize() function. startServer(int port) The startServer method starts the ENet server. It takes an integer port parameter that specifies the port number on which the server should listen for incoming connections. The method performs the following operations: Initializes an ENetAddress structure with the server's IP address (in this example, \"10.50.6.84\") and the port number passed as a parameter. Creates an ENet host using the enet_host_create() function with the address and additional parameters (32 channels, 2 incoming connections, no outgoing bandwidth limit, no incoming bandwidth limit). If the host creation fails, an error is printed, and the program exits with a EXIT_FAILURE exit code. run() The run method is responsible for the main execution of the server. It uses an infinite while loop to wait for and handle network events. The method performs the following operations: Waits for a network event using the enet_host_service() function. If an event is received, it is processed based on its type: ENET_EVENT_TYPE_CONNECT: Prints a message indicating that a client has connected. ENET_EVENT_TYPE_RECEIVE: Prints a message indicating that a packet has been received from the client, then destroys the packet using the enet_packet_destroy() function. ENET_EVENT_TYPE_DISCONNECT: Prints a message indicating that a client has disconnected. The loop continues to wait for new events. stopServer() The stopServer method stops the ENet server by destroying the ENet host using the enet_host_destroy() function. main() function The main function is the entry point of the program. It creates an instance of the ENetServer class, starts the server by calling the startServer() method with the port number passed as a command-line argument (av[1]), and runs the server by calling the run() method. Finally, the main function returns 0 to indicate successful execution. Please note that to use this code, you need to include the \"Serveur.hpp\" header file and the ENet library using #include . Also, make sure you have the ENet library installed and properly configured.","title":"Methods"},{"location":"toolreference/","text":"Tools Reference This section provides reference for the main tools in the R-Type projet: CMake CMake : CMake is an open-source cross-platform build system that is widely used in the software development community. It is designed to automate the build process of software projects, making it easier to compile, test, and package applications across different platforms and build environments. Conan Conan : Conan CMake integration combines the functionality of both Conan and CMake to simplify the management of dependencies in C/C++ projects. It allows you to write CMake code that seamlessly integrates with Conan to handle dependency resolution and retrieval during the build process. With Conan CMake, you can specify your project's dependencies using Conan, and CMake will automatically handle the necessary steps to include and link those dependencies in your project's build. ENet ENet : ENet is an open-source lightweight networking library designed for game development and other real-time communication applications. It stands for \"Efficient Network Library\" and provides a reliable and high-performance network communication protocol for sending and receiving packets of data over the network. SFML SFML : SFML, which stands for Simple and Fast Multimedia Library, is an open-source multimedia library for C++ programming. It provides a simple interface and a set of modules for handling various multimedia tasks such as graphics rendering, window management, audio playback, and input handling. SFML is designed to be easy to use, cross-platform, and efficient.","title":"Tools Reference"},{"location":"toolreference/#tools-reference","text":"This section provides reference for the main tools in the R-Type projet:","title":"Tools Reference"},{"location":"toolreference/#cmake","text":"CMake : CMake is an open-source cross-platform build system that is widely used in the software development community. It is designed to automate the build process of software projects, making it easier to compile, test, and package applications across different platforms and build environments.","title":"CMake"},{"location":"toolreference/#conan","text":"Conan : Conan CMake integration combines the functionality of both Conan and CMake to simplify the management of dependencies in C/C++ projects. It allows you to write CMake code that seamlessly integrates with Conan to handle dependency resolution and retrieval during the build process. With Conan CMake, you can specify your project's dependencies using Conan, and CMake will automatically handle the necessary steps to include and link those dependencies in your project's build.","title":"Conan"},{"location":"toolreference/#enet","text":"ENet : ENet is an open-source lightweight networking library designed for game development and other real-time communication applications. It stands for \"Efficient Network Library\" and provides a reliable and high-performance network communication protocol for sending and receiving packets of data over the network.","title":"ENet"},{"location":"toolreference/#sfml","text":"SFML : SFML, which stands for Simple and Fast Multimedia Library, is an open-source multimedia library for C++ programming. It provides a simple interface and a set of modules for handling various multimedia tasks such as graphics rendering, window management, audio playback, and input handling. SFML is designed to be easy to use, cross-platform, and efficient.","title":"SFML"},{"location":"udp_client/","text":"UdpClient Documentation Description The UdpClient class is a part of the R-Type project. It represents a UDP client that communicates with a server using sockets. The class provides methods for initializing the client, sending and receiving data, and managing the game loop. Header File #include \"../../include/Client/UdpClient.hpp\" Constructors UdpClient(Address serverAddress, Address::Port clientPort) Constructor for the UdpClient class. It initializes the UDP client with the specified server address and client port. Parameters: serverAddress : The address of the server to connect to. clientPort : The port that the client will use to communicate with the server. UdpClient(Address::Port clientPort) Constructor for the UdpClient class. It initializes the UDP client with the specified client port. The server address will be set to 0. Parameters: clientPort : The port that the client will use to communicate with the server. Public Methods void stop() noexcept Stops the execution of the UDP client by setting the looping variable to false. void reset() noexcept Resets the UDP client by setting the looping variable to true. void run() Runs the UDP client by joining the game and network threads. void communicate() noexcept Waits for data to be received or sent and calls the appropriate functions accordingly. void gameLoop() noexcept Runs the game loop. When the user presses the escape key, it sends a CLOSE_VALUE to the server. void receive() Receives data from the socket and handles it. void send() Sends data if there is any in the dataToSend queue. RawData getDataFromQueue() noexcept Returns the first element of the dataToSend queue and removes it from the queue. void handleData(ReceivedInfos infos) noexcept Handles the received data by parsing it and pushing GamePacket objects into the dataReceived queue. void checkServerConnection() noexcept Checks if the server is still connected to the client. Example Usage #include \"../../include/Client/UdpClient.hpp\" int main() { // Create a UDP client with server address and client port Address serverAddress(\"127.0.0.1\", 12345); Address::Port clientPort = 54321; UdpClient client(serverAddress, clientPort); // Run the UDP client client.run(); return 0; } Note: The above example assumes that the necessary header files and libraries are included and linked properly.","title":"UDP Client"},{"location":"udp_client/#udpclient-documentation","text":"Description The UdpClient class is a part of the R-Type project. It represents a UDP client that communicates with a server using sockets. The class provides methods for initializing the client, sending and receiving data, and managing the game loop. Header File #include \"../../include/Client/UdpClient.hpp\"","title":"UdpClient Documentation"},{"location":"udp_client/#constructors","text":"","title":"Constructors"},{"location":"udp_client/#udpclientaddress-serveraddress-addressport-clientport","text":"Constructor for the UdpClient class. It initializes the UDP client with the specified server address and client port. Parameters: serverAddress : The address of the server to connect to. clientPort : The port that the client will use to communicate with the server.","title":"UdpClient(Address serverAddress, Address::Port clientPort)"},{"location":"udp_client/#udpclientaddressport-clientport","text":"Constructor for the UdpClient class. It initializes the UDP client with the specified client port. The server address will be set to 0. Parameters: clientPort : The port that the client will use to communicate with the server.","title":"UdpClient(Address::Port clientPort)"},{"location":"udp_client/#public-methods","text":"","title":"Public Methods"},{"location":"udp_client/#void-stop-noexcept","text":"Stops the execution of the UDP client by setting the looping variable to false.","title":"void stop() noexcept"},{"location":"udp_client/#void-reset-noexcept","text":"Resets the UDP client by setting the looping variable to true.","title":"void reset() noexcept"},{"location":"udp_client/#void-run","text":"Runs the UDP client by joining the game and network threads.","title":"void run()"},{"location":"udp_client/#void-communicate-noexcept","text":"Waits for data to be received or sent and calls the appropriate functions accordingly.","title":"void communicate() noexcept"},{"location":"udp_client/#void-gameloop-noexcept","text":"Runs the game loop. When the user presses the escape key, it sends a CLOSE_VALUE to the server.","title":"void gameLoop() noexcept"},{"location":"udp_client/#void-receive","text":"Receives data from the socket and handles it.","title":"void receive()"},{"location":"udp_client/#void-send","text":"Sends data if there is any in the dataToSend queue.","title":"void send()"},{"location":"udp_client/#rawdata-getdatafromqueue-noexcept","text":"Returns the first element of the dataToSend queue and removes it from the queue.","title":"RawData getDataFromQueue() noexcept"},{"location":"udp_client/#void-handledatareceivedinfos-infos-noexcept","text":"Handles the received data by parsing it and pushing GamePacket objects into the dataReceived queue.","title":"void handleData(ReceivedInfos infos) noexcept"},{"location":"udp_client/#void-checkserverconnection-noexcept","text":"Checks if the server is still connected to the client.","title":"void checkServerConnection() noexcept"},{"location":"udp_client/#example-usage","text":"#include \"../../include/Client/UdpClient.hpp\" int main() { // Create a UDP client with server address and client port Address serverAddress(\"127.0.0.1\", 12345); Address::Port clientPort = 54321; UdpClient client(serverAddress, clientPort); // Run the UDP client client.run(); return 0; } Note: The above example assumes that the necessary header files and libraries are included and linked properly.","title":"Example Usage"},{"location":"windows/","text":"WindowsSocket Documentation The WindowsSocket class provides an implementation of a UDP socket that is compatible with Windows operating systems. It allows for sending and receiving data over UDP. Constructor WindowsSocket(Address::Port port) This constructor initializes a UDP socket and binds it to the specified port. It also reserves memory for the received buffer. Parameters port (Address::Port): The port to bind the socket to. Exceptions InitError : Thrown if the initialization of the socket fails. Destructor ~WindowsSocket() noexcept The destructor for the WindowsSocket class. It cleans up the socket resources and closes the socket. Public Member Functions ISocket::Fd getSocketFd() const noexcept This function returns the socket file descriptor. Return Value ISocket::Fd : The socket file descriptor. Address getAddress() const noexcept This function retrieves the local address to which the socket is bound. Return Value Address : The local address. void send(const void* data, int data_size, Address destAddr) const This function sends data to a specified destination address. Parameters data (const void*): A pointer to the data to be sent. data_size (int): The size of the data to be sent. destAddr (Address): The address of the destination. Exceptions NetworkError : Thrown if an error occurs while sending data. ReceivedInfos receive() This function receives data from a client and returns information about the received data. Return Value ReceivedInfos : A struct containing the sender's address and the received data. Exceptions NetworkError : Thrown if an error occurs while receiving data. Static Member Functions Address winAddressToAddress(SOCKADDR_IN address) noexcept This static function converts a Windows socket address to a cross-platform address. Parameters address (SOCKADDR_IN): The Windows socket address to convert. Return Value Address : The converted cross-platform address. SOCKADDR_IN addressToWinAddress(Address address) noexcept This static function converts an Address object to a Windows SOCKADDR_IN object. Parameters address (Address): The address to convert. Return Value SOCKADDR_IN : The converted Windows socket address. Note: The code provided is specific to Windows platforms and utilizes the Windows Sockets API (WSA). It may not be compatible with other operating systems.","title":"Windows Socket"},{"location":"windows/#windowssocket-documentation","text":"The WindowsSocket class provides an implementation of a UDP socket that is compatible with Windows operating systems. It allows for sending and receiving data over UDP. Constructor","title":"WindowsSocket Documentation"},{"location":"windows/#windowssocketaddressport-port","text":"This constructor initializes a UDP socket and binds it to the specified port. It also reserves memory for the received buffer.","title":"WindowsSocket(Address::Port port)"},{"location":"windows/#parameters","text":"port (Address::Port): The port to bind the socket to.","title":"Parameters"},{"location":"windows/#exceptions","text":"InitError : Thrown if the initialization of the socket fails. Destructor","title":"Exceptions"},{"location":"windows/#windowssocket-noexcept","text":"The destructor for the WindowsSocket class. It cleans up the socket resources and closes the socket.","title":"~WindowsSocket() noexcept"},{"location":"windows/#public-member-functions","text":"","title":"Public Member Functions"},{"location":"windows/#isocketfd-getsocketfd-const-noexcept","text":"This function returns the socket file descriptor.","title":"ISocket::Fd getSocketFd() const noexcept"},{"location":"windows/#return-value","text":"ISocket::Fd : The socket file descriptor.","title":"Return Value"},{"location":"windows/#address-getaddress-const-noexcept","text":"This function retrieves the local address to which the socket is bound.","title":"Address getAddress() const noexcept"},{"location":"windows/#return-value_1","text":"Address : The local address.","title":"Return Value"},{"location":"windows/#void-sendconst-void-data-int-data_size-address-destaddr-const","text":"This function sends data to a specified destination address.","title":"void send(const void* data, int data_size, Address destAddr) const"},{"location":"windows/#parameters_1","text":"data (const void*): A pointer to the data to be sent. data_size (int): The size of the data to be sent. destAddr (Address): The address of the destination.","title":"Parameters"},{"location":"windows/#exceptions_1","text":"NetworkError : Thrown if an error occurs while sending data.","title":"Exceptions"},{"location":"windows/#receivedinfos-receive","text":"This function receives data from a client and returns information about the received data.","title":"ReceivedInfos receive()"},{"location":"windows/#return-value_2","text":"ReceivedInfos : A struct containing the sender's address and the received data.","title":"Return Value"},{"location":"windows/#exceptions_2","text":"NetworkError : Thrown if an error occurs while receiving data.","title":"Exceptions"},{"location":"windows/#static-member-functions","text":"","title":"Static Member Functions"},{"location":"windows/#address-winaddresstoaddresssockaddr_in-address-noexcept","text":"This static function converts a Windows socket address to a cross-platform address.","title":"Address winAddressToAddress(SOCKADDR_IN address) noexcept"},{"location":"windows/#parameters_2","text":"address (SOCKADDR_IN): The Windows socket address to convert.","title":"Parameters"},{"location":"windows/#return-value_3","text":"Address : The converted cross-platform address.","title":"Return Value"},{"location":"windows/#sockaddr_in-addresstowinaddressaddress-address-noexcept","text":"This static function converts an Address object to a Windows SOCKADDR_IN object.","title":"SOCKADDR_IN addressToWinAddress(Address address) noexcept"},{"location":"windows/#parameters_3","text":"address (Address): The address to convert.","title":"Parameters"},{"location":"windows/#return-value_4","text":"SOCKADDR_IN : The converted Windows socket address. Note: The code provided is specific to Windows platforms and utilizes the Windows Sockets API (WSA). It may not be compatible with other operating systems.","title":"Return Value"}]}