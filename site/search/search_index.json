{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Index"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"About Us We are third-year students at EPITECH Cotonou. We are programmers and developers. It's our passion and devotion that motivates us to give our best. Contributors leobasthene.lima deo-gratias.patinvoh ishola.aremou jaurio.dansou mohamed.onifade zaidane.kodjogbe","title":"About"},{"location":"about/#about-us","text":"We are third-year students at EPITECH Cotonou. We are programmers and developers. It's our passion and devotion that motivates us to give our best.","title":"About Us"},{"location":"about/#contributors","text":"leobasthene.lima deo-gratias.patinvoh ishola.aremou jaurio.dansou mohamed.onifade zaidane.kodjogbe","title":"Contributors"},{"location":"client/","text":"Class ClientENet The ClientENet class is responsible for creating and managing an ENet client using the ENet library for network communication. Methods ClientENet() The constructor of the ClientENet class initializes the ENet library by calling the enet_initialize() function. If initialization fails, an error message is printed. ~ClientENet() The destructor of the ClientENet class disconnects from the server by calling the Disconnect() method and releases the resources used by the ENet library by calling the enet_deinitialize() function. Connect(const char* serverAddress, int port) The Connect method connects the client to the server. It takes a serverAddress parameter as a string representing the server's IP address and a port parameter as an integer representing the server's port number. The method performs the following operations: If the client is already connected, it disconnects first by calling the Disconnect() method. Sets the server's address using the enet_address_set_host() function. Creates an ENet host using the enet_host_create() function with parameters (null for the address, 1 channel for outgoing traffic, 2 channels for incoming traffic, no outgoing bandwidth limit, no incoming bandwidth limit). If the host creation fails, an error message is printed, and the method returns false. Connects to the server using the enet_host_connect() function. If the connection to the server is successful, the method waits for an event using the enet_host_service() function. If a connection event is received within 5 seconds, a success message is printed, and the method returns true. Otherwise, a failure message is printed, and the method returns false. Disconnect() The Disconnect method disconnects the client from the server. It resets the peer using the enet_peer_reset() function, flushes the host using the enet_host_flush() function, destroys the host using the enet_host_destroy() function, and sets the client and peer pointers to null. A disconnection message is printed. IsConnected() The IsConnected method checks if the client is connected to the server. It returns true if both the client and peer pointers are not null; otherwise, it returns false. SendData(const void* data, size_t dataSize) The SendData method sends data to the server. It takes a data parameter as a pointer to the data to be sent and a dataSize parameter as the size of the data. The method performs the following operations: Checks if the client is connected. Creates an ENet packet using the enet_packet_create() function with the data, data size, and reliable flag. Sends the packet to the peer using the enet_peer_send() function. Flushes the host using the enet_host_flush() function. Update() The Update method updates the client by handling incoming network events. It checks if the client is connected and then enters a while loop to process events using the enet_host_service() function. The method performs the following operations: Checks if the client is connected. Waits for an event using the enet_host_service() function. Processes the event based on its type: ENET_EVENT_TYPE_RECEIVE: Handles received data by destroying the packet. ENET_EVENT_TYPE_DISCONNECT: Handles disconnection by calling the Disconnect() method. main() function The main function is the entry point of the program. It creates an instance of the ClientENet class and a Window object. It retrieves the server address and port from the command-line arguments. If the client successfully connects to the server, it sends data to the server, runs the window, and enters a loop to update the client while it is connected. If the connection fails, the client is disconnected. Please note that to use this code, you need to include the \"Client.hpp\" header file and the ENet library using #include . Also, make sure you have the ENet library installed and properly configured.","title":"ENet Client"},{"location":"client/#class-clientenet","text":"The ClientENet class is responsible for creating and managing an ENet client using the ENet library for network communication.","title":"Class ClientENet"},{"location":"client/#methods","text":"ClientENet() The constructor of the ClientENet class initializes the ENet library by calling the enet_initialize() function. If initialization fails, an error message is printed. ~ClientENet() The destructor of the ClientENet class disconnects from the server by calling the Disconnect() method and releases the resources used by the ENet library by calling the enet_deinitialize() function. Connect(const char* serverAddress, int port) The Connect method connects the client to the server. It takes a serverAddress parameter as a string representing the server's IP address and a port parameter as an integer representing the server's port number. The method performs the following operations: If the client is already connected, it disconnects first by calling the Disconnect() method. Sets the server's address using the enet_address_set_host() function. Creates an ENet host using the enet_host_create() function with parameters (null for the address, 1 channel for outgoing traffic, 2 channels for incoming traffic, no outgoing bandwidth limit, no incoming bandwidth limit). If the host creation fails, an error message is printed, and the method returns false. Connects to the server using the enet_host_connect() function. If the connection to the server is successful, the method waits for an event using the enet_host_service() function. If a connection event is received within 5 seconds, a success message is printed, and the method returns true. Otherwise, a failure message is printed, and the method returns false. Disconnect() The Disconnect method disconnects the client from the server. It resets the peer using the enet_peer_reset() function, flushes the host using the enet_host_flush() function, destroys the host using the enet_host_destroy() function, and sets the client and peer pointers to null. A disconnection message is printed. IsConnected() The IsConnected method checks if the client is connected to the server. It returns true if both the client and peer pointers are not null; otherwise, it returns false. SendData(const void* data, size_t dataSize) The SendData method sends data to the server. It takes a data parameter as a pointer to the data to be sent and a dataSize parameter as the size of the data. The method performs the following operations: Checks if the client is connected. Creates an ENet packet using the enet_packet_create() function with the data, data size, and reliable flag. Sends the packet to the peer using the enet_peer_send() function. Flushes the host using the enet_host_flush() function. Update() The Update method updates the client by handling incoming network events. It checks if the client is connected and then enters a while loop to process events using the enet_host_service() function. The method performs the following operations: Checks if the client is connected. Waits for an event using the enet_host_service() function. Processes the event based on its type: ENET_EVENT_TYPE_RECEIVE: Handles received data by destroying the packet. ENET_EVENT_TYPE_DISCONNECT: Handles disconnection by calling the Disconnect() method. main() function The main function is the entry point of the program. It creates an instance of the ClientENet class and a Window object. It retrieves the server address and port from the command-line arguments. If the client successfully connects to the server, it sends data to the server, runs the window, and enters a loop to update the client while it is connected. If the connection fails, the client is disconnected. Please note that to use this code, you need to include the \"Client.hpp\" header file and the ENet library using #include . Also, make sure you have the ENet library installed and properly configured.","title":"Methods"},{"location":"ecs_component/","text":"Documentation for ComponentBehavior Description The ComponentBehavior class is a derived class of IComponent and represents the behavior component of an entity. It provides functionality for updating the entity's behavior. Public Members ComponentBehavior() : Default constructor. ~ComponentBehavior() : Default destructor. void setupdate(std::function<void(Entity* entity)> update) : Sets the update function for the component. void Update(Entity* entity) : Updates the behavior of the entity. Protected Members None. Private Members std::function<void(Entity* self)> _update_ : Function object representing the update function for the component. Documentation for ComponentDraw Description The ComponentDraw class is a derived class of IComponent and represents the drawing component of an entity. It provides functionality for managing the position, size, scale, and texture ID of the entity's sprite. Public Members ComponentDraw(int X, int Y, int width, int height, int textureId) : Constructor that initializes the drawing component with the specified position, size, and texture ID. ~ComponentDraw() : Destructor. std::tuple<int, int> getX_Y() noexcept : Returns the X and Y coordinates of the drawing component. std::tuple<int, int> getHeightandWidth() noexcept : Returns the height and width of the drawing component. std::tuple<double, double> getScaleX_Y() noexcept : Returns the X and Y scale factors of the drawing component. int getTextureId() noexcept : Returns the texture ID of the drawing component. void setWidth(int width) noexcept : Sets the width of the drawing component. void setHeight(int height) noexcept : Sets the height of the drawing component. void setScale(float x, float y) noexcept : Sets the X and Y scale factors of the drawing component. void setTextureId(int textureId) noexcept : Sets the texture ID of the drawing component. Sprite& getSprite() noexcept : Returns a reference to the sprite associated with the drawing component. Protected Members None. Private Members int _X : The X coordinate of the drawing component. int _Y : The Y coordinate of the drawing component. int _width : The width of the drawing component. int _heigth : The height of the drawing component. int _textureId : The texture ID of the drawing component. double _scaleX : The X scale factor of the drawing component. double _scaleY : The Y scale factor of the drawing component. Sprite sprite_ : The sprite associated with the drawing component. Documentation for ComponentInput Description The ComponentInput class is a derived class of IComponent and represents the input component of an entity. It provides functionality for managing input values associated with the entity. Public Members ComponentInput() : Default constructor. ~ComponentInput() : Default destructor. void addInput(int input) noexcept : Adds an input value to the component. int getInput() noexcept : Returns the input value associated with the component. Protected Members None. Private Members std::vector<int> _input : A vector storing the input values associated with the component. Documentation for ComponentMouvement Description The ComponentMouvement class is a derived class of IComponent and represents the movement component of an entity. It provides functionality for managing the position and speed of the entity. Public Members ComponentMouvement(int X, int Y, double speed) : Constructor that initializes the movement component with the specified position and speed. ~ComponentMouvement() : Destructor. std::tuple<int, int> getXandY() noexcept : Returns the X and Y coordinates of the movement component. double getSpeed() noexcept : Returns the speed of the movement component. void setX(int X) noexcept : Sets the X coordinate of the movement component. void setY(int Y) noexcept : Sets the Y coordinate of the movement component. void setSpeed(double speed) noexcept : Sets the speed of the movement component. Protected Members None. Private Members int _X : The X coordinate of the movement component. int _Y : The Y coordinate of the movement component. double _speed : The speed of the movement component. Documentation for ComponentPosition Description The ComponentPosition class is a derived class of IComponent and represents the position component of an entity. It provides functionality for managing the position of the entity. Public Members ComponentPosition(int x, int y) noexcept : Constructor that initializes the position component with the specified coordinates. ~ComponentPosition() noexcept : Destructor. std::tuple<int, int> getXandY() const noexcept : Returns the X and Y coordinates of the position component. void setXandY(int x, int y) noexcept : Sets the X and Y coordinates of the position component. Protected Members int _x : The X coordinate of the position component. int _y : The Y coordinate of the position component. Private Members None. Please note that this documentation is based on the provided code snippets and may not cover all the details or context of the entire system. It is recommended to refer to the actual code implementation and any associated comments for a complete understanding.","title":"ECS Component"},{"location":"ecs_component/#documentation-for-componentbehavior","text":"","title":"Documentation for ComponentBehavior"},{"location":"ecs_component/#description","text":"The ComponentBehavior class is a derived class of IComponent and represents the behavior component of an entity. It provides functionality for updating the entity's behavior.","title":"Description"},{"location":"ecs_component/#public-members","text":"ComponentBehavior() : Default constructor. ~ComponentBehavior() : Default destructor. void setupdate(std::function<void(Entity* entity)> update) : Sets the update function for the component. void Update(Entity* entity) : Updates the behavior of the entity.","title":"Public Members"},{"location":"ecs_component/#protected-members","text":"None.","title":"Protected Members"},{"location":"ecs_component/#private-members","text":"std::function<void(Entity* self)> _update_ : Function object representing the update function for the component.","title":"Private Members"},{"location":"ecs_component/#documentation-for-componentdraw","text":"","title":"Documentation for ComponentDraw"},{"location":"ecs_component/#description_1","text":"The ComponentDraw class is a derived class of IComponent and represents the drawing component of an entity. It provides functionality for managing the position, size, scale, and texture ID of the entity's sprite.","title":"Description"},{"location":"ecs_component/#public-members_1","text":"ComponentDraw(int X, int Y, int width, int height, int textureId) : Constructor that initializes the drawing component with the specified position, size, and texture ID. ~ComponentDraw() : Destructor. std::tuple<int, int> getX_Y() noexcept : Returns the X and Y coordinates of the drawing component. std::tuple<int, int> getHeightandWidth() noexcept : Returns the height and width of the drawing component. std::tuple<double, double> getScaleX_Y() noexcept : Returns the X and Y scale factors of the drawing component. int getTextureId() noexcept : Returns the texture ID of the drawing component. void setWidth(int width) noexcept : Sets the width of the drawing component. void setHeight(int height) noexcept : Sets the height of the drawing component. void setScale(float x, float y) noexcept : Sets the X and Y scale factors of the drawing component. void setTextureId(int textureId) noexcept : Sets the texture ID of the drawing component. Sprite& getSprite() noexcept : Returns a reference to the sprite associated with the drawing component.","title":"Public Members"},{"location":"ecs_component/#protected-members_1","text":"None.","title":"Protected Members"},{"location":"ecs_component/#private-members_1","text":"int _X : The X coordinate of the drawing component. int _Y : The Y coordinate of the drawing component. int _width : The width of the drawing component. int _heigth : The height of the drawing component. int _textureId : The texture ID of the drawing component. double _scaleX : The X scale factor of the drawing component. double _scaleY : The Y scale factor of the drawing component. Sprite sprite_ : The sprite associated with the drawing component.","title":"Private Members"},{"location":"ecs_component/#documentation-for-componentinput","text":"","title":"Documentation for ComponentInput"},{"location":"ecs_component/#description_2","text":"The ComponentInput class is a derived class of IComponent and represents the input component of an entity. It provides functionality for managing input values associated with the entity.","title":"Description"},{"location":"ecs_component/#public-members_2","text":"ComponentInput() : Default constructor. ~ComponentInput() : Default destructor. void addInput(int input) noexcept : Adds an input value to the component. int getInput() noexcept : Returns the input value associated with the component.","title":"Public Members"},{"location":"ecs_component/#protected-members_2","text":"None.","title":"Protected Members"},{"location":"ecs_component/#private-members_2","text":"std::vector<int> _input : A vector storing the input values associated with the component.","title":"Private Members"},{"location":"ecs_component/#documentation-for-componentmouvement","text":"","title":"Documentation for ComponentMouvement"},{"location":"ecs_component/#description_3","text":"The ComponentMouvement class is a derived class of IComponent and represents the movement component of an entity. It provides functionality for managing the position and speed of the entity.","title":"Description"},{"location":"ecs_component/#public-members_3","text":"ComponentMouvement(int X, int Y, double speed) : Constructor that initializes the movement component with the specified position and speed. ~ComponentMouvement() : Destructor. std::tuple<int, int> getXandY() noexcept : Returns the X and Y coordinates of the movement component. double getSpeed() noexcept : Returns the speed of the movement component. void setX(int X) noexcept : Sets the X coordinate of the movement component. void setY(int Y) noexcept : Sets the Y coordinate of the movement component. void setSpeed(double speed) noexcept : Sets the speed of the movement component.","title":"Public Members"},{"location":"ecs_component/#protected-members_3","text":"None.","title":"Protected Members"},{"location":"ecs_component/#private-members_3","text":"int _X : The X coordinate of the movement component. int _Y : The Y coordinate of the movement component. double _speed : The speed of the movement component.","title":"Private Members"},{"location":"ecs_component/#documentation-for-componentposition","text":"","title":"Documentation for ComponentPosition"},{"location":"ecs_component/#description_4","text":"The ComponentPosition class is a derived class of IComponent and represents the position component of an entity. It provides functionality for managing the position of the entity.","title":"Description"},{"location":"ecs_component/#public-members_4","text":"ComponentPosition(int x, int y) noexcept : Constructor that initializes the position component with the specified coordinates. ~ComponentPosition() noexcept : Destructor. std::tuple<int, int> getXandY() const noexcept : Returns the X and Y coordinates of the position component. void setXandY(int x, int y) noexcept : Sets the X and Y coordinates of the position component.","title":"Public Members"},{"location":"ecs_component/#protected-members_4","text":"int _x : The X coordinate of the position component. int _y : The Y coordinate of the position component.","title":"Protected Members"},{"location":"ecs_component/#private-members_4","text":"None. Please note that this documentation is based on the provided code snippets and may not cover all the details or context of the entire system. It is recommended to refer to the actual code implementation and any associated comments for a complete understanding.","title":"Private Members"},{"location":"ecs_entity/","text":"Documentation for Entity Description The Entity class represents an entity in a game or simulation. It is a container for components that define the properties and behaviors of the entity. Each entity has a unique identifier. Public Members Entity(size_t id) noexcept : Constructor that creates an entity with the specified identifier. ~Entity() noexcept : Destructor. size_t getIdex() noexcept : Returns the identifier of the entity. std::vector<std::shared_ptr<IComponent>>& getEntityComponent() noexcept : Returns a reference to the vector of components associated with the entity. template <typename T> void addComponent(T& component) noexcept : Adds a component of type T to the entity. template <typename T> T* getComponent() noexcept : Returns a pointer to the component of type T associated with the entity. template <typename T> int EntityhaveComponent() noexcept : Checks if the entity has a component of type T . template <typename T, typename... Args> bool hasComponents() noexcept : Checks if the entity has components of types T and Args... . Protected Members None. Private Members std::vector<std::shared_ptr<IComponent>> _component : A vector of shared pointers to the components associated with the entity. size_t _id : The identifier of the entity. Documentation for EntityManager Description The EntityManager class manages a collection of entities. It provides functionality for creating, accessing, and removing entities. Public Members EntityManager() noexcept : Default constructor. ~EntityManager() noexcept : Destructor. std::shared_ptr<Entity> CreateEntity() noexcept : Creates a new entity and returns a shared pointer to it. std::vector<std::shared_ptr<Entity>>& getEntity() noexcept : Returns a reference to the vector of entities managed by the entity manager. std::shared_ptr<Entity> findEntity(size_t id) noexcept : Finds an entity with the specified identifier and returns a shared pointer to it. int eraseEntity(size_t id) noexcept : Removes an entity with the specified identifier from the entity manager. Protected Members None. Private Members std::vector<std::shared_ptr<Entity>> _entity : A vector of shared pointers to the entities managed by the entity manager. Please note that this documentation is based on the provided code snippets and may not cover all the details or context of the entire system. It is recommended to refer to the actual code implementation and any associated comments for a complete understanding.","title":"ECS Entity"},{"location":"ecs_entity/#documentation-for-entity","text":"","title":"Documentation for Entity"},{"location":"ecs_entity/#description","text":"The Entity class represents an entity in a game or simulation. It is a container for components that define the properties and behaviors of the entity. Each entity has a unique identifier.","title":"Description"},{"location":"ecs_entity/#public-members","text":"Entity(size_t id) noexcept : Constructor that creates an entity with the specified identifier. ~Entity() noexcept : Destructor. size_t getIdex() noexcept : Returns the identifier of the entity. std::vector<std::shared_ptr<IComponent>>& getEntityComponent() noexcept : Returns a reference to the vector of components associated with the entity. template <typename T> void addComponent(T& component) noexcept : Adds a component of type T to the entity. template <typename T> T* getComponent() noexcept : Returns a pointer to the component of type T associated with the entity. template <typename T> int EntityhaveComponent() noexcept : Checks if the entity has a component of type T . template <typename T, typename... Args> bool hasComponents() noexcept : Checks if the entity has components of types T and Args... .","title":"Public Members"},{"location":"ecs_entity/#protected-members","text":"None.","title":"Protected Members"},{"location":"ecs_entity/#private-members","text":"std::vector<std::shared_ptr<IComponent>> _component : A vector of shared pointers to the components associated with the entity. size_t _id : The identifier of the entity.","title":"Private Members"},{"location":"ecs_entity/#documentation-for-entitymanager","text":"","title":"Documentation for EntityManager"},{"location":"ecs_entity/#description_1","text":"The EntityManager class manages a collection of entities. It provides functionality for creating, accessing, and removing entities.","title":"Description"},{"location":"ecs_entity/#public-members_1","text":"EntityManager() noexcept : Default constructor. ~EntityManager() noexcept : Destructor. std::shared_ptr<Entity> CreateEntity() noexcept : Creates a new entity and returns a shared pointer to it. std::vector<std::shared_ptr<Entity>>& getEntity() noexcept : Returns a reference to the vector of entities managed by the entity manager. std::shared_ptr<Entity> findEntity(size_t id) noexcept : Finds an entity with the specified identifier and returns a shared pointer to it. int eraseEntity(size_t id) noexcept : Removes an entity with the specified identifier from the entity manager.","title":"Public Members"},{"location":"ecs_entity/#protected-members_1","text":"None.","title":"Protected Members"},{"location":"ecs_entity/#private-members_1","text":"std::vector<std::shared_ptr<Entity>> _entity : A vector of shared pointers to the entities managed by the entity manager. Please note that this documentation is based on the provided code snippets and may not cover all the details or context of the entire system. It is recommended to refer to the actual code implementation and any associated comments for a complete understanding.","title":"Private Members"},{"location":"ecs_system/","text":"Documentation for SystemBehavior Description The SystemBehavior class is a component that represents a behavior system in a game or simulation. It inherits from the IComponent interface. It provides functionality for managing and executing behaviors associated with entities. Public Members SystemBehavior(EntityManager *entity) : Constructor that initializes the behavior system with a pointer to the EntityManager . ~SystemBehavior() : Destructor. void loop() : Performs the behavior system's main loop, where behaviors are executed. Protected Members None. Private Members EntityManager *_entityManager : A pointer to the EntityManager that manages the entities associated with the behavior system. Documentation for SystemDraw Description The SystemDraw class is responsible for drawing entities in a game or simulation. It provides functionality for rendering entities with visual components. Public Members SystemDraw(EntityManager *entity) : Constructor that initializes the drawing system with a pointer to the EntityManager . ~SystemDraw() : Destructor. void loop() : Performs the drawing system's main loop, where entities are rendered. void setWindow(Window* window) noexcept : Sets the window in which the entities will be drawn. Protected Members None. Private Members Window *_window : A pointer to the window where entities will be drawn. EntityManager *_entity : A pointer to the EntityManager that manages the entities associated with the drawing system. Documentation for SystemMouvement Description The SystemMouvement class is responsible for handling movement-related logic in a game or simulation. It provides functionality for updating the positions of entities with movement components. Public Members SystemMouvement(EntityManager *entity) : Constructor that initializes the movement system with a pointer to the EntityManager . ~SystemMouvement() : Destructor. void loop() : Performs the movement system's main loop, where entity positions are updated. Protected Members None. Private Members EntityManager *_entity : A pointer to the EntityManager that manages the entities associated with the movement system. Documentation for SystemMusic Description The SystemMusic class is a component that represents a music system in a game or simulation. It inherits from the IComponent interface. It provides functionality for managing and playing music associated with entities. Public Members SystemMusic(EntityManager *entity) : Constructor that initializes the music system with a pointer to the EntityManager . ~SystemMusic() : Destructor. void loop() : Performs the music system's main loop, where music is played. Protected Members None. Private Members EntityManager *_entitymanager : A pointer to the EntityManager that manages the entities associated with the music system. Documentation for SystemSound Description The SystemSound class is responsible for handling sound-related logic in a game or simulation. It provides functionality for playing sounds associated with entities. Public Members SystemSound(EntityManager *entitymanager) : Constructor that initializes the sound system with a pointer to the EntityManager . ~SystemSound() : Destructor. void loop() : Performs the sound system's main loop, where sounds are played. void setSoundManager(SoundManager* soundManager) noexcept : Sets the sound manager responsible for playing the sounds. Protected Members None. Private Members EntityManager *_entitymanager : A pointer to the EntityManager that manages the entities associated with the sound system. SoundManager *soundManager_ : A pointer to the sound manager responsible for playing the sounds. Please note that this documentation is based on the provided code snippets and may not cover all the details or context of the entire system. It is recommended to refer to the actual code implementation and any associated comments for a complete understanding.","title":"ECS System"},{"location":"ecs_system/#documentation-for-systembehavior","text":"","title":"Documentation for SystemBehavior"},{"location":"ecs_system/#description","text":"The SystemBehavior class is a component that represents a behavior system in a game or simulation. It inherits from the IComponent interface. It provides functionality for managing and executing behaviors associated with entities.","title":"Description"},{"location":"ecs_system/#public-members","text":"SystemBehavior(EntityManager *entity) : Constructor that initializes the behavior system with a pointer to the EntityManager . ~SystemBehavior() : Destructor. void loop() : Performs the behavior system's main loop, where behaviors are executed.","title":"Public Members"},{"location":"ecs_system/#protected-members","text":"None.","title":"Protected Members"},{"location":"ecs_system/#private-members","text":"EntityManager *_entityManager : A pointer to the EntityManager that manages the entities associated with the behavior system.","title":"Private Members"},{"location":"ecs_system/#documentation-for-systemdraw","text":"","title":"Documentation for SystemDraw"},{"location":"ecs_system/#description_1","text":"The SystemDraw class is responsible for drawing entities in a game or simulation. It provides functionality for rendering entities with visual components.","title":"Description"},{"location":"ecs_system/#public-members_1","text":"SystemDraw(EntityManager *entity) : Constructor that initializes the drawing system with a pointer to the EntityManager . ~SystemDraw() : Destructor. void loop() : Performs the drawing system's main loop, where entities are rendered. void setWindow(Window* window) noexcept : Sets the window in which the entities will be drawn.","title":"Public Members"},{"location":"ecs_system/#protected-members_1","text":"None.","title":"Protected Members"},{"location":"ecs_system/#private-members_1","text":"Window *_window : A pointer to the window where entities will be drawn. EntityManager *_entity : A pointer to the EntityManager that manages the entities associated with the drawing system.","title":"Private Members"},{"location":"ecs_system/#documentation-for-systemmouvement","text":"","title":"Documentation for SystemMouvement"},{"location":"ecs_system/#description_2","text":"The SystemMouvement class is responsible for handling movement-related logic in a game or simulation. It provides functionality for updating the positions of entities with movement components.","title":"Description"},{"location":"ecs_system/#public-members_2","text":"SystemMouvement(EntityManager *entity) : Constructor that initializes the movement system with a pointer to the EntityManager . ~SystemMouvement() : Destructor. void loop() : Performs the movement system's main loop, where entity positions are updated.","title":"Public Members"},{"location":"ecs_system/#protected-members_2","text":"None.","title":"Protected Members"},{"location":"ecs_system/#private-members_2","text":"EntityManager *_entity : A pointer to the EntityManager that manages the entities associated with the movement system.","title":"Private Members"},{"location":"ecs_system/#documentation-for-systemmusic","text":"","title":"Documentation for SystemMusic"},{"location":"ecs_system/#description_3","text":"The SystemMusic class is a component that represents a music system in a game or simulation. It inherits from the IComponent interface. It provides functionality for managing and playing music associated with entities.","title":"Description"},{"location":"ecs_system/#public-members_3","text":"SystemMusic(EntityManager *entity) : Constructor that initializes the music system with a pointer to the EntityManager . ~SystemMusic() : Destructor. void loop() : Performs the music system's main loop, where music is played.","title":"Public Members"},{"location":"ecs_system/#protected-members_3","text":"None.","title":"Protected Members"},{"location":"ecs_system/#private-members_3","text":"EntityManager *_entitymanager : A pointer to the EntityManager that manages the entities associated with the music system.","title":"Private Members"},{"location":"ecs_system/#documentation-for-systemsound","text":"","title":"Documentation for SystemSound"},{"location":"ecs_system/#description_4","text":"The SystemSound class is responsible for handling sound-related logic in a game or simulation. It provides functionality for playing sounds associated with entities.","title":"Description"},{"location":"ecs_system/#public-members_4","text":"SystemSound(EntityManager *entitymanager) : Constructor that initializes the sound system with a pointer to the EntityManager . ~SystemSound() : Destructor. void loop() : Performs the sound system's main loop, where sounds are played. void setSoundManager(SoundManager* soundManager) noexcept : Sets the sound manager responsible for playing the sounds.","title":"Public Members"},{"location":"ecs_system/#protected-members_4","text":"None.","title":"Protected Members"},{"location":"ecs_system/#private-members_4","text":"EntityManager *_entitymanager : A pointer to the EntityManager that manages the entities associated with the sound system. SoundManager *soundManager_ : A pointer to the sound manager responsible for playing the sounds. Please note that this documentation is based on the provided code snippets and may not cover all the details or context of the entire system. It is recommended to refer to the actual code implementation and any associated comments for a complete understanding.","title":"Private Members"},{"location":"game_server/","text":"GameEngine::createPlayer int GameEngine::createPlayer(int x, int y, int nb) noexcept Description This function is responsible for creating a player entity in the game. It creates and configures the necessary components for the player entity, such as draw, position, movement, and input. Parameters * x (int): The initial x-coordinate of the player's position. * y (int): The initial y-coordinate of the player's position. * nb (int): The player number. Return Value int: The index of the created player entity. Example Usage int playerIndex = gameEngine.createPlayer(100, 200, 1); GameEngine::createPlayerBullet int GameEngine::createPlayerBullet(int x, int y, float damage, float speed, int dirX, int dirY, float size) noexcept Description This function is responsible for creating a player bullet entity in the game. It creates and configures the necessary components for the bullet entity. Parameters * x (int): The initial x-coordinate of the bullet's position. * y (int): The initial y-coordinate of the bullet's position. * damage (float): The damage inflicted by the bullet. * speed (float): The speed of the bullet. * dirX (int): The x-direction of the bullet. * dirY (int): The y-direction of the bullet. * size (float): The size of the bullet. Return Value int: The index of the created bullet entity. Example Usage int bulletIndex = gameEngine.createPlayerBullet(150, 300, 10.0f, 8.0f, 1, 0, 0.5f); Please note that this documentation is generated based on the provided code snippet, and the actual functionality and usage of these functions may depend on the implementation details not provided in the code.","title":"Game server"},{"location":"game_server/#gameenginecreateplayer","text":"int GameEngine::createPlayer(int x, int y, int nb) noexcept Description This function is responsible for creating a player entity in the game. It creates and configures the necessary components for the player entity, such as draw, position, movement, and input. Parameters * x (int): The initial x-coordinate of the player's position. * y (int): The initial y-coordinate of the player's position. * nb (int): The player number. Return Value int: The index of the created player entity. Example Usage int playerIndex = gameEngine.createPlayer(100, 200, 1);","title":"GameEngine::createPlayer"},{"location":"game_server/#gameenginecreateplayerbullet","text":"int GameEngine::createPlayerBullet(int x, int y, float damage, float speed, int dirX, int dirY, float size) noexcept Description This function is responsible for creating a player bullet entity in the game. It creates and configures the necessary components for the bullet entity. Parameters * x (int): The initial x-coordinate of the bullet's position. * y (int): The initial y-coordinate of the bullet's position. * damage (float): The damage inflicted by the bullet. * speed (float): The speed of the bullet. * dirX (int): The x-direction of the bullet. * dirY (int): The y-direction of the bullet. * size (float): The size of the bullet. Return Value int: The index of the created bullet entity. Example Usage int bulletIndex = gameEngine.createPlayerBullet(150, 300, 10.0f, 8.0f, 1, 0, 0.5f); Please note that this documentation is generated based on the provided code snippet, and the actual functionality and usage of these functions may depend on the implementation details not provided in the code.","title":"GameEngine::createPlayerBullet"},{"location":"lib_client/","text":"Lib Client The provided code consists of several C++ class definitions. Here's a brief explanation of each class: Buffer This class represents a sound buffer. It uses the SFML library's sf::SoundBuffer to load and store audio data from a file. The Buffer class has a private member mybuffer of type sf::SoundBuffer and a public member function getSoundBuffer() that returns a reference to the sound buffer. Lib This class represents a library and contains a Window object named lafenetre. It provides a member function getWindow() to access the Window object. Music This class represents a music player. It uses the SFML library's sf::Music to load and play music from a file. The Music class has private members mymusic_path to store the path of the music file and mymusic as a shared pointer to sf::Music. It provides member functions to control the playback of the music, such as play(), pause(), stop(), setVolume(), setLoop(), etc. SoundManager This class manages multiple sound buffers. It has private members buffers_ and buffersPaths_ to store instances of the Buffer class and their corresponding file paths. It provides member functions to add sound buffers and retrieve a buffer based on its path. Sound This class represents a sound player. It uses the SFML library's sf::Sound to play sounds using a sound buffer. The Sound class has a private member mysound of type sf::Sound and a std::string member soundPath to store the path of the sound file. It provides member functions to control the playback of the sound, such as play(), pause(), stop(), setVolume(), etc. Sprite This class represents a sprite, which is an image that can be displayed on the screen. It uses the SFML library's sf::Sprite and sf::Texture classes to load and display the sprite image. The Sprite class has private members spritePath to store the path of the sprite image file, coordx and coordy to store the position of the sprite, sprite of type sf::Sprite to represent the sprite, and texture_sprite of type sf::Texture to store the texture of the sprite. It provides member functions to set and retrieve the properties of the sprite, such as setSpritePath(), getX(), getY(), etc. Text This class represents text that can be displayed on the screen. It uses the SFML library's sf::Text and sf::Font classes to load and display the text. The Text class has private members mytext of type sf::Text to store the text object, myfont of type sf::Font to store the font used for the text, coordx and coordy to store the position of the text, and mycolor of type sf::Color to store the color of the text. It provides member functions to set and retrieve the properties of the text, such as setTextString(), setFontPath(), setFontSize(), getX(), getY(), etc. These classes can be used to create and manipulate audio, visual, and text elements in a C++ program using the SFML library.","title":"Lib Client"},{"location":"lib_client/#lib-client","text":"The provided code consists of several C++ class definitions. Here's a brief explanation of each class:","title":"Lib Client"},{"location":"lib_client/#buffer","text":"This class represents a sound buffer. It uses the SFML library's sf::SoundBuffer to load and store audio data from a file. The Buffer class has a private member mybuffer of type sf::SoundBuffer and a public member function getSoundBuffer() that returns a reference to the sound buffer.","title":"Buffer"},{"location":"lib_client/#lib","text":"This class represents a library and contains a Window object named lafenetre. It provides a member function getWindow() to access the Window object.","title":"Lib"},{"location":"lib_client/#music","text":"This class represents a music player. It uses the SFML library's sf::Music to load and play music from a file. The Music class has private members mymusic_path to store the path of the music file and mymusic as a shared pointer to sf::Music. It provides member functions to control the playback of the music, such as play(), pause(), stop(), setVolume(), setLoop(), etc.","title":"Music"},{"location":"lib_client/#soundmanager","text":"This class manages multiple sound buffers. It has private members buffers_ and buffersPaths_ to store instances of the Buffer class and their corresponding file paths. It provides member functions to add sound buffers and retrieve a buffer based on its path.","title":"SoundManager"},{"location":"lib_client/#sound","text":"This class represents a sound player. It uses the SFML library's sf::Sound to play sounds using a sound buffer. The Sound class has a private member mysound of type sf::Sound and a std::string member soundPath to store the path of the sound file. It provides member functions to control the playback of the sound, such as play(), pause(), stop(), setVolume(), etc.","title":"Sound"},{"location":"lib_client/#sprite","text":"This class represents a sprite, which is an image that can be displayed on the screen. It uses the SFML library's sf::Sprite and sf::Texture classes to load and display the sprite image. The Sprite class has private members spritePath to store the path of the sprite image file, coordx and coordy to store the position of the sprite, sprite of type sf::Sprite to represent the sprite, and texture_sprite of type sf::Texture to store the texture of the sprite. It provides member functions to set and retrieve the properties of the sprite, such as setSpritePath(), getX(), getY(), etc.","title":"Sprite"},{"location":"lib_client/#text","text":"This class represents text that can be displayed on the screen. It uses the SFML library's sf::Text and sf::Font classes to load and display the text. The Text class has private members mytext of type sf::Text to store the text object, myfont of type sf::Font to store the font used for the text, coordx and coordy to store the position of the text, and mycolor of type sf::Color to store the color of the text. It provides member functions to set and retrieve the properties of the text, such as setTextString(), setFontPath(), setFontSize(), getX(), getY(), etc. These classes can be used to create and manipulate audio, visual, and text elements in a C++ program using the SFML library.","title":"Text"},{"location":"present/","text":"Welcome to R-TYPE The goal is to implement a multithreaded server and a graphical client for a well-known legacy video game called R-Type, using a game engine of your own design. Language: Advanced C++ Build tool The project must be built using a CMake and dependencies must be handled using conan. Graphique We used SFML for client-side displays and all rendering was done using SFML. Network The network library is the package that enables the various clients to communicate with the server and play with their friends. The principle is simple: you connect via TCP, which manages several game servers using the UDP protocol. The client is then directly redirected to an available game server and switches to UDP communication to play.","title":"Home"},{"location":"present/#welcome-to-r-type","text":"The goal is to implement a multithreaded server and a graphical client for a well-known legacy video game called R-Type, using a game engine of your own design. Language: Advanced C++","title":"Welcome to R-TYPE"},{"location":"present/#build-tool","text":"The project must be built using a CMake and dependencies must be handled using conan.","title":"Build tool"},{"location":"present/#graphique","text":"We used SFML for client-side displays and all rendering was done using SFML.","title":"Graphique"},{"location":"present/#network","text":"The network library is the package that enables the various clients to communicate with the server and play with their friends. The principle is simple: you connect via TCP, which manages several game servers using the UDP protocol. The client is then directly redirected to an available game server and switches to UDP communication to play.","title":"Network"},{"location":"rfcprotocole/","text":"Protocole RFC This note is the official specification for the two R-Type protocols (the R-Type TCP protocol and the R-Type UDP protocol). Introduction The aim of the R-Type project is to create an online multiplayer copy of the classic multiplayer online game R-Type (1987). R-Type architecture R-Type's architecture is a classic client-server game architecture architecture. The entire game engine is located in the server. A client connects connects to the server using the R-Type TCP protocol. Once connected, the client can choose between creating a new lobby or joining an existing one. Several clients can connect to the server at the same time. Next, the customer who created the lobby can start a new game. The server can run several games at the same time. R-Type TCP Protocol All client-server communication prior to game launch is carried out using this using this R-type TCP protocol. These codes define the different actions that we will observe at the with the action assigned to each function. The ACTION enumeration: enum ACTION { 500 = KO, 230 = CONNECT, 332 = JOIN, 201 = READY, 200 = START, 221 = DECONNECTION, 250 = MOVE, 257 = SHOOT, 530 = QUIT, 211 = LEFT, 212 = RIGHT, 213 = UP, 214 = DOWN }; To send a payload, each piece of data must be written to the socket so that the actions behind it can be executed. Code explanations To explain what's going on, we need to understand that these different codes have a very precise meaning for the customer. In this way, the customer relies on these various codes to respond to the instructions. 500 = KO : This allows the customer to understand that the message has not not reached its destination. So there's an error in the message reception 230 = connect : This tells the client that it has successfully connected to the server, enabling further communication. 332 = join : This allows you to manage the integration of a new a new player into an existing or exixtante game. 201 = ready : This code is used to recognize at customer level whether a party has started. 221 = deconnection : From its name with the code, this lets us know that the client server has been disconnected. 250 = move : This code lets the customer know that there is an entity entity performing a movement. 257 = shoot : This code can be used to identify interactions between player and enemy interactions. 530 = quit : This code, when sent, lets the customer know to know that it must completely disconnect from the client. 211 = left : This code allows us to identify that the entity moves to the left. 212 = right : This code allows us to identify that the entity moves to the right. 213 = up : This code allows us to identify that the entity is moving upwards. 214 = down : This code allows us to identify that the entity is moving downwards. Once the server has received these different codes, it knows exactly what action to execute. This ensures a smooth collision between the different entities in the game. Reception at the server's After sending these different codes, the server receives them and then goes on to process the retrieved information. With these codes, the waiter would know what to do with his level. And this is how it reacts to the different codes. When the server receives: 500 : This tells the server that there has been a connection problem. 230 : This code notifies the customer that the connection has been been established. 332 : This tells the server that an entity has joined a player group or a new game. 201 : This enables the server to create the entities required to generate a game. 221 : When this code is sent to the server level, the latter deletes the entities to end the game. 250 : On seeing this code, the server increments the position of the entity. 257 : Once this code has been sent to the server, the latter activates the entity responsible for managing in-game shooting events 530 : The latter lets the server know that it's time to to break the connection with the client. 211 : This allows the server to move the moving entity left on the abssice axis. 212 : This allows the server to move the moving entity right on the abssice axis. 213 : Cela permet au serveur d\u00e9plac\u00e9 l'entit\u00e9 en mouvement vers la haut sur l'axe de ordonn\u00e9. 214 : This allows the server to move the moving entity down the order axis. Finally, we need to understand that it's these different codes that server and client to communicate with each other. So we can quickly detect problems.","title":"Protocole RFC"},{"location":"rfcprotocole/#protocole-rfc","text":"This note is the official specification for the two R-Type protocols (the R-Type TCP protocol and the R-Type UDP protocol).","title":"Protocole RFC"},{"location":"rfcprotocole/#introduction","text":"The aim of the R-Type project is to create an online multiplayer copy of the classic multiplayer online game R-Type (1987).","title":"Introduction"},{"location":"rfcprotocole/#r-type-architecture","text":"R-Type's architecture is a classic client-server game architecture architecture. The entire game engine is located in the server. A client connects connects to the server using the R-Type TCP protocol. Once connected, the client can choose between creating a new lobby or joining an existing one. Several clients can connect to the server at the same time. Next, the customer who created the lobby can start a new game. The server can run several games at the same time.","title":"R-Type architecture"},{"location":"rfcprotocole/#r-type-tcp-protocol","text":"All client-server communication prior to game launch is carried out using this using this R-type TCP protocol. These codes define the different actions that we will observe at the with the action assigned to each function. The ACTION enumeration: enum ACTION { 500 = KO, 230 = CONNECT, 332 = JOIN, 201 = READY, 200 = START, 221 = DECONNECTION, 250 = MOVE, 257 = SHOOT, 530 = QUIT, 211 = LEFT, 212 = RIGHT, 213 = UP, 214 = DOWN }; To send a payload, each piece of data must be written to the socket so that the actions behind it can be executed.","title":"R-Type TCP Protocol"},{"location":"rfcprotocole/#code-explanations","text":"To explain what's going on, we need to understand that these different codes have a very precise meaning for the customer. In this way, the customer relies on these various codes to respond to the instructions. 500 = KO : This allows the customer to understand that the message has not not reached its destination. So there's an error in the message reception 230 = connect : This tells the client that it has successfully connected to the server, enabling further communication. 332 = join : This allows you to manage the integration of a new a new player into an existing or exixtante game. 201 = ready : This code is used to recognize at customer level whether a party has started. 221 = deconnection : From its name with the code, this lets us know that the client server has been disconnected. 250 = move : This code lets the customer know that there is an entity entity performing a movement. 257 = shoot : This code can be used to identify interactions between player and enemy interactions. 530 = quit : This code, when sent, lets the customer know to know that it must completely disconnect from the client. 211 = left : This code allows us to identify that the entity moves to the left. 212 = right : This code allows us to identify that the entity moves to the right. 213 = up : This code allows us to identify that the entity is moving upwards. 214 = down : This code allows us to identify that the entity is moving downwards. Once the server has received these different codes, it knows exactly what action to execute. This ensures a smooth collision between the different entities in the game.","title":"Code explanations"},{"location":"rfcprotocole/#reception-at-the-servers","text":"After sending these different codes, the server receives them and then goes on to process the retrieved information. With these codes, the waiter would know what to do with his level. And this is how it reacts to the different codes. When the server receives: 500 : This tells the server that there has been a connection problem. 230 : This code notifies the customer that the connection has been been established. 332 : This tells the server that an entity has joined a player group or a new game. 201 : This enables the server to create the entities required to generate a game. 221 : When this code is sent to the server level, the latter deletes the entities to end the game. 250 : On seeing this code, the server increments the position of the entity. 257 : Once this code has been sent to the server, the latter activates the entity responsible for managing in-game shooting events 530 : The latter lets the server know that it's time to to break the connection with the client. 211 : This allows the server to move the moving entity left on the abssice axis. 212 : This allows the server to move the moving entity right on the abssice axis. 213 : Cela permet au serveur d\u00e9plac\u00e9 l'entit\u00e9 en mouvement vers la haut sur l'axe de ordonn\u00e9. 214 : This allows the server to move the moving entity down the order axis. Finally, we need to understand that it's these different codes that server and client to communicate with each other. So we can quickly detect problems.","title":"Reception at the server's"},{"location":"serveur/","text":"Class ServerENet The ENetServer class is responsible for creating and managing an ENet server using the ENet library for network communication. Methods ENetServer() The constructor of the ENetServer class initializes the ENet library by calling the enet_initialize() function. If initialization fails, an error is printed, and the program exits with a EXIT_FAILURE exit code. * ~ENetServer() The destructor of the ENetServer class releases the resources used by the ENet library by calling the enet_deinitialize() function. startServer(int port) The startServer method starts the ENet server. It takes an integer port parameter that specifies the port number on which the server should listen for incoming connections. The method performs the following operations: Initializes an ENetAddress structure with the server's IP address (in this example, \"10.50.6.84\") and the port number passed as a parameter. Creates an ENet host using the enet_host_create() function with the address and additional parameters (32 channels, 2 incoming connections, no outgoing bandwidth limit, no incoming bandwidth limit). If the host creation fails, an error is printed, and the program exits with a EXIT_FAILURE exit code. run() The run method is responsible for the main execution of the server. It uses an infinite while loop to wait for and handle network events. The method performs the following operations: Waits for a network event using the enet_host_service() function. If an event is received, it is processed based on its type: ENET_EVENT_TYPE_CONNECT: Prints a message indicating that a client has connected. ENET_EVENT_TYPE_RECEIVE: Prints a message indicating that a packet has been received from the client, then destroys the packet using the enet_packet_destroy() function. ENET_EVENT_TYPE_DISCONNECT: Prints a message indicating that a client has disconnected. The loop continues to wait for new events. stopServer() The stopServer method stops the ENet server by destroying the ENet host using the enet_host_destroy() function. main() function The main function is the entry point of the program. It creates an instance of the ENetServer class, starts the server by calling the startServer() method with the port number passed as a command-line argument (av[1]), and runs the server by calling the run() method. Finally, the main function returns 0 to indicate successful execution. Please note that to use this code, you need to include the \"Serveur.hpp\" header file and the ENet library using #include . Also, make sure you have the ENet library installed and properly configured.","title":"ENet Server"},{"location":"serveur/#class-serverenet","text":"The ENetServer class is responsible for creating and managing an ENet server using the ENet library for network communication.","title":"Class ServerENet"},{"location":"serveur/#methods","text":"ENetServer() The constructor of the ENetServer class initializes the ENet library by calling the enet_initialize() function. If initialization fails, an error is printed, and the program exits with a EXIT_FAILURE exit code. * ~ENetServer() The destructor of the ENetServer class releases the resources used by the ENet library by calling the enet_deinitialize() function. startServer(int port) The startServer method starts the ENet server. It takes an integer port parameter that specifies the port number on which the server should listen for incoming connections. The method performs the following operations: Initializes an ENetAddress structure with the server's IP address (in this example, \"10.50.6.84\") and the port number passed as a parameter. Creates an ENet host using the enet_host_create() function with the address and additional parameters (32 channels, 2 incoming connections, no outgoing bandwidth limit, no incoming bandwidth limit). If the host creation fails, an error is printed, and the program exits with a EXIT_FAILURE exit code. run() The run method is responsible for the main execution of the server. It uses an infinite while loop to wait for and handle network events. The method performs the following operations: Waits for a network event using the enet_host_service() function. If an event is received, it is processed based on its type: ENET_EVENT_TYPE_CONNECT: Prints a message indicating that a client has connected. ENET_EVENT_TYPE_RECEIVE: Prints a message indicating that a packet has been received from the client, then destroys the packet using the enet_packet_destroy() function. ENET_EVENT_TYPE_DISCONNECT: Prints a message indicating that a client has disconnected. The loop continues to wait for new events. stopServer() The stopServer method stops the ENet server by destroying the ENet host using the enet_host_destroy() function. main() function The main function is the entry point of the program. It creates an instance of the ENetServer class, starts the server by calling the startServer() method with the port number passed as a command-line argument (av[1]), and runs the server by calling the run() method. Finally, the main function returns 0 to indicate successful execution. Please note that to use this code, you need to include the \"Serveur.hpp\" header file and the ENet library using #include . Also, make sure you have the ENet library installed and properly configured.","title":"Methods"},{"location":"tool/","text":"Shortcut Way Description The Shortcut Way header file defines various shortcuts and paths used in the game. It includes definitions for sprite paths, audio paths, and a few constant strings. Macros * SPRITE(id): * Description: Macro for constructing the path of a sprite based on its ID. * Parameters: id (string): The ID of the sprite. * Example: std::string spritePath = SPRITE(\"enemy\"); AUDIO(name): * Description: Macro for constructing the path of an audio file based on its name. * Parameters: name (string): The name of the audio file. * Example: std::string audioPath = AUDIO(\"explosion.wav\"); Constants * EXPLOSION_PATH: * Description: The path of the explosion sound effect audio file. * Type: std::string * Example: std::string explosionPath = EXPLOSION_PATH; HEAL_PATH: * Description: The path of the heal sound effect audio file. * Type: std::string * Example: std::string healPath = HEAL_PATH; HURT_PATH: * Description: The path of the hurt sound effect audio file. * Type: std::string * Example: std::string hurtPath = HURT_PATH; MENU_PATH: * Description: The path of the menu sound effect audio file. * Type: std::string * Example: std::string menuPath = MENU_PATH; PIOU_PATH: * Description: The path of the piou sound effect audio file. * Type: std::string * Example: std::string piouPath = PIOU_PATH; POWERUP_PATH: * Description: The path of the power-up sound effect audio file. * Type: std::string * Example: std::string powerUpPath = POWERUP_PATH; MUSIC_BG_PATH: * Description: The path of the background music audio file. * Type: std::string * Example: std::string musicBgPath = MUSIC_BG_PATH; Touch Description The Touch enumeration defines various touch inputs available in the game. It represents different key inputs or touch gestures that can be used for interaction. Enumerators * None to Exit: * Description: Touch enumerators representing different touch inputs. * Type: Touch * Example: Touch touchInput = Touch::Left; Please note that this documentation is generated based on the provided code snippets, and the actual functionality and usage of these definitions may depend on the implementation details not provided in the code.","title":"Tool"},{"location":"tool/#shortcut-way","text":"","title":"Shortcut Way"},{"location":"tool/#description","text":"The Shortcut Way header file defines various shortcuts and paths used in the game. It includes definitions for sprite paths, audio paths, and a few constant strings.","title":"Description"},{"location":"tool/#macros","text":"* SPRITE(id): * Description: Macro for constructing the path of a sprite based on its ID. * Parameters: id (string): The ID of the sprite. * Example: std::string spritePath = SPRITE(\"enemy\");","title":"Macros"},{"location":"tool/#audioname","text":"* Description: Macro for constructing the path of an audio file based on its name. * Parameters: name (string): The name of the audio file. * Example: std::string audioPath = AUDIO(\"explosion.wav\");","title":"AUDIO(name):"},{"location":"tool/#constants","text":"* EXPLOSION_PATH: * Description: The path of the explosion sound effect audio file. * Type: std::string * Example: std::string explosionPath = EXPLOSION_PATH;","title":"Constants"},{"location":"tool/#heal_path","text":"* Description: The path of the heal sound effect audio file. * Type: std::string * Example: std::string healPath = HEAL_PATH;","title":"HEAL_PATH:"},{"location":"tool/#hurt_path","text":"* Description: The path of the hurt sound effect audio file. * Type: std::string * Example: std::string hurtPath = HURT_PATH;","title":"HURT_PATH:"},{"location":"tool/#menu_path","text":"* Description: The path of the menu sound effect audio file. * Type: std::string * Example: std::string menuPath = MENU_PATH;","title":"MENU_PATH:"},{"location":"tool/#piou_path","text":"* Description: The path of the piou sound effect audio file. * Type: std::string * Example: std::string piouPath = PIOU_PATH;","title":"PIOU_PATH:"},{"location":"tool/#powerup_path","text":"* Description: The path of the power-up sound effect audio file. * Type: std::string * Example: std::string powerUpPath = POWERUP_PATH;","title":"POWERUP_PATH:"},{"location":"tool/#music_bg_path","text":"* Description: The path of the background music audio file. * Type: std::string * Example: std::string musicBgPath = MUSIC_BG_PATH;","title":"MUSIC_BG_PATH:"},{"location":"tool/#touch","text":"","title":"Touch"},{"location":"tool/#description_1","text":"The Touch enumeration defines various touch inputs available in the game. It represents different key inputs or touch gestures that can be used for interaction.","title":"Description"},{"location":"tool/#enumerators","text":"* None to Exit: * Description: Touch enumerators representing different touch inputs. * Type: Touch * Example: Touch touchInput = Touch::Left; Please note that this documentation is generated based on the provided code snippets, and the actual functionality and usage of these definitions may depend on the implementation details not provided in the code.","title":"Enumerators"},{"location":"toolreference/","text":"Tools Reference This section provides reference for the main tools in the R-Type projet: CMake CMake : CMake is an open-source cross-platform build system that is widely used in the software development community. It is designed to automate the build process of software projects, making it easier to compile, test, and package applications across different platforms and build environments. Conan Conan : Conan CMake integration combines the functionality of both Conan and CMake to simplify the management of dependencies in C/C++ projects. It allows you to write CMake code that seamlessly integrates with Conan to handle dependency resolution and retrieval during the build process. With Conan CMake, you can specify your project's dependencies using Conan, and CMake will automatically handle the necessary steps to include and link those dependencies in your project's build. ENet ENet : ENet is an open-source lightweight networking library designed for game development and other real-time communication applications. It stands for \"Efficient Network Library\" and provides a reliable and high-performance network communication protocol for sending and receiving packets of data over the network. SFML SFML : SFML, which stands for Simple and Fast Multimedia Library, is an open-source multimedia library for C++ programming. It provides a simple interface and a set of modules for handling various multimedia tasks such as graphics rendering, window management, audio playback, and input handling. SFML is designed to be easy to use, cross-platform, and efficient.","title":"Tools Reference"},{"location":"toolreference/#tools-reference","text":"This section provides reference for the main tools in the R-Type projet:","title":"Tools Reference"},{"location":"toolreference/#cmake","text":"CMake : CMake is an open-source cross-platform build system that is widely used in the software development community. It is designed to automate the build process of software projects, making it easier to compile, test, and package applications across different platforms and build environments.","title":"CMake"},{"location":"toolreference/#conan","text":"Conan : Conan CMake integration combines the functionality of both Conan and CMake to simplify the management of dependencies in C/C++ projects. It allows you to write CMake code that seamlessly integrates with Conan to handle dependency resolution and retrieval during the build process. With Conan CMake, you can specify your project's dependencies using Conan, and CMake will automatically handle the necessary steps to include and link those dependencies in your project's build.","title":"Conan"},{"location":"toolreference/#enet","text":"ENet : ENet is an open-source lightweight networking library designed for game development and other real-time communication applications. It stands for \"Efficient Network Library\" and provides a reliable and high-performance network communication protocol for sending and receiving packets of data over the network.","title":"ENet"},{"location":"toolreference/#sfml","text":"SFML : SFML, which stands for Simple and Fast Multimedia Library, is an open-source multimedia library for C++ programming. It provides a simple interface and a set of modules for handling various multimedia tasks such as graphics rendering, window management, audio playback, and input handling. SFML is designed to be easy to use, cross-platform, and efficient.","title":"SFML"}]}