{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Index"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"About Us We are third-year students at EPITECH Cotonou. We are programmers and developers. It's our passion and devotion that motivates us to give our best. Contributors leobasthene.lima deo-gratias.patinvoh ishola.aremou jaurio.dansou mohamed.onifade zaidane.kodjogbe","title":"About"},{"location":"about/#about-us","text":"We are third-year students at EPITECH Cotonou. We are programmers and developers. It's our passion and devotion that motivates us to give our best.","title":"About Us"},{"location":"about/#contributors","text":"leobasthene.lima deo-gratias.patinvoh ishola.aremou jaurio.dansou mohamed.onifade zaidane.kodjogbe","title":"Contributors"},{"location":"client/","text":"Class ClientENet The ClientENet class is responsible for creating and managing an ENet client using the ENet library for network communication. Methods ClientENet() The constructor of the ClientENet class initializes the ENet library by calling the enet_initialize() function. If initialization fails, an error message is printed. ~ClientENet() The destructor of the ClientENet class disconnects from the server by calling the Disconnect() method and releases the resources used by the ENet library by calling the enet_deinitialize() function. Connect(const char* serverAddress, int port) The Connect method connects the client to the server. It takes a serverAddress parameter as a string representing the server's IP address and a port parameter as an integer representing the server's port number. The method performs the following operations: If the client is already connected, it disconnects first by calling the Disconnect() method. Sets the server's address using the enet_address_set_host() function. Creates an ENet host using the enet_host_create() function with parameters (null for the address, 1 channel for outgoing traffic, 2 channels for incoming traffic, no outgoing bandwidth limit, no incoming bandwidth limit). If the host creation fails, an error message is printed, and the method returns false. Connects to the server using the enet_host_connect() function. If the connection to the server is successful, the method waits for an event using the enet_host_service() function. If a connection event is received within 5 seconds, a success message is printed, and the method returns true. Otherwise, a failure message is printed, and the method returns false. Disconnect() The Disconnect method disconnects the client from the server. It resets the peer using the enet_peer_reset() function, flushes the host using the enet_host_flush() function, destroys the host using the enet_host_destroy() function, and sets the client and peer pointers to null. A disconnection message is printed. IsConnected() The IsConnected method checks if the client is connected to the server. It returns true if both the client and peer pointers are not null; otherwise, it returns false. SendData(const void* data, size_t dataSize) The SendData method sends data to the server. It takes a data parameter as a pointer to the data to be sent and a dataSize parameter as the size of the data. The method performs the following operations: Checks if the client is connected. Creates an ENet packet using the enet_packet_create() function with the data, data size, and reliable flag. Sends the packet to the peer using the enet_peer_send() function. Flushes the host using the enet_host_flush() function. Update() The Update method updates the client by handling incoming network events. It checks if the client is connected and then enters a while loop to process events using the enet_host_service() function. The method performs the following operations: Checks if the client is connected. Waits for an event using the enet_host_service() function. Processes the event based on its type: ENET_EVENT_TYPE_RECEIVE: Handles received data by destroying the packet. ENET_EVENT_TYPE_DISCONNECT: Handles disconnection by calling the Disconnect() method. main() function The main function is the entry point of the program. It creates an instance of the ClientENet class and a Window object. It retrieves the server address and port from the command-line arguments. If the client successfully connects to the server, it sends data to the server, runs the window, and enters a loop to update the client while it is connected. If the connection fails, the client is disconnected. Please note that to use this code, you need to include the \"Client.hpp\" header file and the ENet library using #include . Also, make sure you have the ENet library installed and properly configured.","title":"ENet Client"},{"location":"client/#class-clientenet","text":"The ClientENet class is responsible for creating and managing an ENet client using the ENet library for network communication.","title":"Class ClientENet"},{"location":"client/#methods","text":"ClientENet() The constructor of the ClientENet class initializes the ENet library by calling the enet_initialize() function. If initialization fails, an error message is printed. ~ClientENet() The destructor of the ClientENet class disconnects from the server by calling the Disconnect() method and releases the resources used by the ENet library by calling the enet_deinitialize() function. Connect(const char* serverAddress, int port) The Connect method connects the client to the server. It takes a serverAddress parameter as a string representing the server's IP address and a port parameter as an integer representing the server's port number. The method performs the following operations: If the client is already connected, it disconnects first by calling the Disconnect() method. Sets the server's address using the enet_address_set_host() function. Creates an ENet host using the enet_host_create() function with parameters (null for the address, 1 channel for outgoing traffic, 2 channels for incoming traffic, no outgoing bandwidth limit, no incoming bandwidth limit). If the host creation fails, an error message is printed, and the method returns false. Connects to the server using the enet_host_connect() function. If the connection to the server is successful, the method waits for an event using the enet_host_service() function. If a connection event is received within 5 seconds, a success message is printed, and the method returns true. Otherwise, a failure message is printed, and the method returns false. Disconnect() The Disconnect method disconnects the client from the server. It resets the peer using the enet_peer_reset() function, flushes the host using the enet_host_flush() function, destroys the host using the enet_host_destroy() function, and sets the client and peer pointers to null. A disconnection message is printed. IsConnected() The IsConnected method checks if the client is connected to the server. It returns true if both the client and peer pointers are not null; otherwise, it returns false. SendData(const void* data, size_t dataSize) The SendData method sends data to the server. It takes a data parameter as a pointer to the data to be sent and a dataSize parameter as the size of the data. The method performs the following operations: Checks if the client is connected. Creates an ENet packet using the enet_packet_create() function with the data, data size, and reliable flag. Sends the packet to the peer using the enet_peer_send() function. Flushes the host using the enet_host_flush() function. Update() The Update method updates the client by handling incoming network events. It checks if the client is connected and then enters a while loop to process events using the enet_host_service() function. The method performs the following operations: Checks if the client is connected. Waits for an event using the enet_host_service() function. Processes the event based on its type: ENET_EVENT_TYPE_RECEIVE: Handles received data by destroying the packet. ENET_EVENT_TYPE_DISCONNECT: Handles disconnection by calling the Disconnect() method. main() function The main function is the entry point of the program. It creates an instance of the ClientENet class and a Window object. It retrieves the server address and port from the command-line arguments. If the client successfully connects to the server, it sends data to the server, runs the window, and enters a loop to update the client while it is connected. If the connection fails, the client is disconnected. Please note that to use this code, you need to include the \"Client.hpp\" header file and the ENet library using #include . Also, make sure you have the ENet library installed and properly configured.","title":"Methods"},{"location":"present/","text":"Welcome to R-TYPE The goal is to implement a multithreaded server and a graphical client for a well-known legacy video game called R-Type, using a game engine of your own design. Language: Advanced C++ Build tool The project must be built using a CMake and dependencies must be handled using conan. Graphique We used SFML for client-side displays and all rendering was done using SFML. Network The network library is the package that enables the various clients to communicate with the server and play with their friends. The principle is simple: you connect via TCP, which manages several game servers using the UDP protocol. The client is then directly redirected to an available game server and switches to UDP communication to play.","title":"Home"},{"location":"present/#welcome-to-r-type","text":"The goal is to implement a multithreaded server and a graphical client for a well-known legacy video game called R-Type, using a game engine of your own design. Language: Advanced C++","title":"Welcome to R-TYPE"},{"location":"present/#build-tool","text":"The project must be built using a CMake and dependencies must be handled using conan.","title":"Build tool"},{"location":"present/#graphique","text":"We used SFML for client-side displays and all rendering was done using SFML.","title":"Graphique"},{"location":"present/#network","text":"The network library is the package that enables the various clients to communicate with the server and play with their friends. The principle is simple: you connect via TCP, which manages several game servers using the UDP protocol. The client is then directly redirected to an available game server and switches to UDP communication to play.","title":"Network"},{"location":"rfcprotocole/","text":"Protocole RFC This note is the official specification for the two R-Type protocols (the R-Type TCP protocol and the R-Type UDP protocol). Introduction The aim of the R-Type project is to create an online multiplayer copy of the classic multiplayer online game R-Type (1987). R-Type architecture R-Type's architecture is a classic client-server game architecture architecture. The entire game engine is located in the server. A client connects connects to the server using the R-Type TCP protocol. Once connected, the client can choose between creating a new lobby or joining an existing one. Several clients can connect to the server at the same time. Next, the customer who created the lobby can start a new game. The server can run several games at the same time. R-Type TCP Protocol All client-server communication prior to game launch is carried out using this using this R-type TCP protocol. These codes define the different actions that we will observe at the with the action assigned to each function. The ACTION enumeration: enum ACTION { 500 = KO, 230 = CONNECT, 332 = JOIN, 201 = READY, 200 = START, 221 = DECONNECTION, 250 = MOVE, 257 = SHOOT, 530 = QUIT, 211 = LEFT, 212 = RIGHT, 213 = UP, 214 = DOWN }; To send a payload, each piece of data must be written to the socket so that the actions behind it can be executed. Code explanations To explain what's going on, we need to understand that these different codes have a very precise meaning for the customer. In this way, the customer relies on these various codes to respond to the instructions. 500 = KO : This allows the customer to understand that the message has not not reached its destination. So there's an error in the message reception 230 = connect : This tells the client that it has successfully connected to the server, enabling further communication. 332 = join : This allows you to manage the integration of a new a new player into an existing or exixtante game. 201 = ready : This code is used to recognize at customer level whether a party has started. 221 = deconnection : From its name with the code, this lets us know that the client server has been disconnected. 250 = move : This code lets the customer know that there is an entity entity performing a movement. 257 = shoot : This code can be used to identify interactions between player and enemy interactions. 530 = quit : This code, when sent, lets the customer know to know that it must completely disconnect from the client. 211 = left : This code allows us to identify that the entity moves to the left. 212 = right : This code allows us to identify that the entity moves to the right. 213 = up : This code allows us to identify that the entity is moving upwards. 214 = down : This code allows us to identify that the entity is moving downwards. Once the server has received these different codes, it knows exactly what action to execute. This ensures a smooth collision between the different entities in the game. Reception at the server's After sending these different codes, the server receives them and then goes on to process the retrieved information. With these codes, the waiter would know what to do with his level. And this is how it reacts to the different codes. When the server receives: 500 : This tells the server that there has been a connection problem. 230 : This code notifies the customer that the connection has been been established. 332 : This tells the server that an entity has joined a player group or a new game. 201 : This enables the server to create the entities required to generate a game. 221 : When this code is sent to the server level, the latter deletes the entities to end the game. 250 : On seeing this code, the server increments the position of the entity. 257 : Once this code has been sent to the server, the latter activates the entity responsible for managing in-game shooting events 530 : The latter lets the server know that it's time to to break the connection with the client. 211 : This allows the server to move the moving entity left on the abssice axis. 212 : This allows the server to move the moving entity right on the abssice axis. 213 : Cela permet au serveur d\u00e9plac\u00e9 l'entit\u00e9 en mouvement vers la haut sur l'axe de ordonn\u00e9. 214 : This allows the server to move the moving entity down the order axis. Finally, we need to understand that it's these different codes that server and client to communicate with each other. So we can quickly detect problems.","title":"Protocole RFC"},{"location":"rfcprotocole/#protocole-rfc","text":"This note is the official specification for the two R-Type protocols (the R-Type TCP protocol and the R-Type UDP protocol).","title":"Protocole RFC"},{"location":"rfcprotocole/#introduction","text":"The aim of the R-Type project is to create an online multiplayer copy of the classic multiplayer online game R-Type (1987).","title":"Introduction"},{"location":"rfcprotocole/#r-type-architecture","text":"R-Type's architecture is a classic client-server game architecture architecture. The entire game engine is located in the server. A client connects connects to the server using the R-Type TCP protocol. Once connected, the client can choose between creating a new lobby or joining an existing one. Several clients can connect to the server at the same time. Next, the customer who created the lobby can start a new game. The server can run several games at the same time.","title":"R-Type architecture"},{"location":"rfcprotocole/#r-type-tcp-protocol","text":"All client-server communication prior to game launch is carried out using this using this R-type TCP protocol. These codes define the different actions that we will observe at the with the action assigned to each function. The ACTION enumeration: enum ACTION { 500 = KO, 230 = CONNECT, 332 = JOIN, 201 = READY, 200 = START, 221 = DECONNECTION, 250 = MOVE, 257 = SHOOT, 530 = QUIT, 211 = LEFT, 212 = RIGHT, 213 = UP, 214 = DOWN }; To send a payload, each piece of data must be written to the socket so that the actions behind it can be executed.","title":"R-Type TCP Protocol"},{"location":"rfcprotocole/#code-explanations","text":"To explain what's going on, we need to understand that these different codes have a very precise meaning for the customer. In this way, the customer relies on these various codes to respond to the instructions. 500 = KO : This allows the customer to understand that the message has not not reached its destination. So there's an error in the message reception 230 = connect : This tells the client that it has successfully connected to the server, enabling further communication. 332 = join : This allows you to manage the integration of a new a new player into an existing or exixtante game. 201 = ready : This code is used to recognize at customer level whether a party has started. 221 = deconnection : From its name with the code, this lets us know that the client server has been disconnected. 250 = move : This code lets the customer know that there is an entity entity performing a movement. 257 = shoot : This code can be used to identify interactions between player and enemy interactions. 530 = quit : This code, when sent, lets the customer know to know that it must completely disconnect from the client. 211 = left : This code allows us to identify that the entity moves to the left. 212 = right : This code allows us to identify that the entity moves to the right. 213 = up : This code allows us to identify that the entity is moving upwards. 214 = down : This code allows us to identify that the entity is moving downwards. Once the server has received these different codes, it knows exactly what action to execute. This ensures a smooth collision between the different entities in the game.","title":"Code explanations"},{"location":"rfcprotocole/#reception-at-the-servers","text":"After sending these different codes, the server receives them and then goes on to process the retrieved information. With these codes, the waiter would know what to do with his level. And this is how it reacts to the different codes. When the server receives: 500 : This tells the server that there has been a connection problem. 230 : This code notifies the customer that the connection has been been established. 332 : This tells the server that an entity has joined a player group or a new game. 201 : This enables the server to create the entities required to generate a game. 221 : When this code is sent to the server level, the latter deletes the entities to end the game. 250 : On seeing this code, the server increments the position of the entity. 257 : Once this code has been sent to the server, the latter activates the entity responsible for managing in-game shooting events 530 : The latter lets the server know that it's time to to break the connection with the client. 211 : This allows the server to move the moving entity left on the abssice axis. 212 : This allows the server to move the moving entity right on the abssice axis. 213 : Cela permet au serveur d\u00e9plac\u00e9 l'entit\u00e9 en mouvement vers la haut sur l'axe de ordonn\u00e9. 214 : This allows the server to move the moving entity down the order axis. Finally, we need to understand that it's these different codes that server and client to communicate with each other. So we can quickly detect problems.","title":"Reception at the server's"},{"location":"serveur/","text":"Class ENetServer The ENetServer class is responsible for creating and managing an ENet server using the ENet library for network communication. Methods ENetServer() The constructor of the ENetServer class initializes the ENet library by calling the enet_initialize() function. If initialization fails, an error is printed, and the program exits with a EXIT_FAILURE exit code. * ~ENetServer() The destructor of the ENetServer class releases the resources used by the ENet library by calling the enet_deinitialize() function. startServer(int port) The startServer method starts the ENet server. It takes an integer port parameter that specifies the port number on which the server should listen for incoming connections. The method performs the following operations: Initializes an ENetAddress structure with the server's IP address (in this example, \"10.50.6.84\") and the port number passed as a parameter. Creates an ENet host using the enet_host_create() function with the address and additional parameters (32 channels, 2 incoming connections, no outgoing bandwidth limit, no incoming bandwidth limit). If the host creation fails, an error is printed, and the program exits with a EXIT_FAILURE exit code. run() The run method is responsible for the main execution of the server. It uses an infinite while loop to wait for and handle network events. The method performs the following operations: Waits for a network event using the enet_host_service() function. If an event is received, it is processed based on its type: ENET_EVENT_TYPE_CONNECT: Prints a message indicating that a client has connected. ENET_EVENT_TYPE_RECEIVE: Prints a message indicating that a packet has been received from the client, then destroys the packet using the enet_packet_destroy() function. ENET_EVENT_TYPE_DISCONNECT: Prints a message indicating that a client has disconnected. The loop continues to wait for new events. stopServer() The stopServer method stops the ENet server by destroying the ENet host using the enet_host_destroy() function. main() function The main function is the entry point of the program. It creates an instance of the ENetServer class, starts the server by calling the startServer() method with the port number passed as a command-line argument (av[1]), and runs the server by calling the run() method. Finally, the main function returns 0 to indicate successful execution. Please note that to use this code, you need to include the \"Serveur.hpp\" header file and the ENet library using #include . Also, make sure you have the ENet library installed and properly configured.","title":"ENet Server"},{"location":"serveur/#class-enetserver","text":"The ENetServer class is responsible for creating and managing an ENet server using the ENet library for network communication.","title":"Class ENetServer"},{"location":"serveur/#methods","text":"ENetServer() The constructor of the ENetServer class initializes the ENet library by calling the enet_initialize() function. If initialization fails, an error is printed, and the program exits with a EXIT_FAILURE exit code. * ~ENetServer() The destructor of the ENetServer class releases the resources used by the ENet library by calling the enet_deinitialize() function. startServer(int port) The startServer method starts the ENet server. It takes an integer port parameter that specifies the port number on which the server should listen for incoming connections. The method performs the following operations: Initializes an ENetAddress structure with the server's IP address (in this example, \"10.50.6.84\") and the port number passed as a parameter. Creates an ENet host using the enet_host_create() function with the address and additional parameters (32 channels, 2 incoming connections, no outgoing bandwidth limit, no incoming bandwidth limit). If the host creation fails, an error is printed, and the program exits with a EXIT_FAILURE exit code. run() The run method is responsible for the main execution of the server. It uses an infinite while loop to wait for and handle network events. The method performs the following operations: Waits for a network event using the enet_host_service() function. If an event is received, it is processed based on its type: ENET_EVENT_TYPE_CONNECT: Prints a message indicating that a client has connected. ENET_EVENT_TYPE_RECEIVE: Prints a message indicating that a packet has been received from the client, then destroys the packet using the enet_packet_destroy() function. ENET_EVENT_TYPE_DISCONNECT: Prints a message indicating that a client has disconnected. The loop continues to wait for new events. stopServer() The stopServer method stops the ENet server by destroying the ENet host using the enet_host_destroy() function. main() function The main function is the entry point of the program. It creates an instance of the ENetServer class, starts the server by calling the startServer() method with the port number passed as a command-line argument (av[1]), and runs the server by calling the run() method. Finally, the main function returns 0 to indicate successful execution. Please note that to use this code, you need to include the \"Serveur.hpp\" header file and the ENet library using #include . Also, make sure you have the ENet library installed and properly configured.","title":"Methods"},{"location":"toolreference/","text":"Tools Reference This section provides reference for the main tools in the R-Type projet: CMake CMake : CMake is an open-source cross-platform build system that is widely used in the software development community. It is designed to automate the build process of software projects, making it easier to compile, test, and package applications across different platforms and build environments. Conan Conan : Conan CMake integration combines the functionality of both Conan and CMake to simplify the management of dependencies in C/C++ projects. It allows you to write CMake code that seamlessly integrates with Conan to handle dependency resolution and retrieval during the build process. With Conan CMake, you can specify your project's dependencies using Conan, and CMake will automatically handle the necessary steps to include and link those dependencies in your project's build. ENet ENet : ENet is an open-source lightweight networking library designed for game development and other real-time communication applications. It stands for \"Efficient Network Library\" and provides a reliable and high-performance network communication protocol for sending and receiving packets of data over the network. SFML SFML : SFML, which stands for Simple and Fast Multimedia Library, is an open-source multimedia library for C++ programming. It provides a simple interface and a set of modules for handling various multimedia tasks such as graphics rendering, window management, audio playback, and input handling. SFML is designed to be easy to use, cross-platform, and efficient.","title":"Tools Reference"},{"location":"toolreference/#tools-reference","text":"This section provides reference for the main tools in the R-Type projet:","title":"Tools Reference"},{"location":"toolreference/#cmake","text":"CMake : CMake is an open-source cross-platform build system that is widely used in the software development community. It is designed to automate the build process of software projects, making it easier to compile, test, and package applications across different platforms and build environments.","title":"CMake"},{"location":"toolreference/#conan","text":"Conan : Conan CMake integration combines the functionality of both Conan and CMake to simplify the management of dependencies in C/C++ projects. It allows you to write CMake code that seamlessly integrates with Conan to handle dependency resolution and retrieval during the build process. With Conan CMake, you can specify your project's dependencies using Conan, and CMake will automatically handle the necessary steps to include and link those dependencies in your project's build.","title":"Conan"},{"location":"toolreference/#enet","text":"ENet : ENet is an open-source lightweight networking library designed for game development and other real-time communication applications. It stands for \"Efficient Network Library\" and provides a reliable and high-performance network communication protocol for sending and receiving packets of data over the network.","title":"ENet"},{"location":"toolreference/#sfml","text":"SFML : SFML, which stands for Simple and Fast Multimedia Library, is an open-source multimedia library for C++ programming. It provides a simple interface and a set of modules for handling various multimedia tasks such as graphics rendering, window management, audio playback, and input handling. SFML is designed to be easy to use, cross-platform, and efficient.","title":"SFML"}]}